<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>7.5. Chuẩn hoá theo batch &#8212; Đắm mình vào Học Sâu 0.14.4 documentation</title>

    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/d2l.css" />
    <link rel="stylesheet" href="../_static/material-design-lite-1.3.0/material.blue-deep_orange.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx_materialdesign_theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fontawesome/all.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/d2l.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7.6. Mạng phần dư (ResNet)" href="resnet_vn.html" />
    <link rel="prev" title="7.4. Mạng nối song song (GoogLeNet)" href="googlenet_vn.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link" href="index_vn.html"><span class="section-number">7. </span>Mạng Nơ-ron Tích chập Hiện đại</a><i class="material-icons">navigate_next</i>
            <a class="mdl-navigation__link is-active"><span class="section-number">7.5. </span>Chuẩn hoá theo batch</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../_sources/chapter_convolutional-modern/batch-norm_vn.rst.txt" rel="nofollow">
  <i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
          
              <a  class="mdl-navigation__link" href="https://github.com/aivivn/d2l-vn">
                  <i class="fab fa-github"></i>
                  GitHub
              </a>
          
              <a  class="mdl-navigation__link" href="https://forum.machinelearningcoban.com/">
                  <i class="fab fa-discourse"></i>
                  Forum
              </a>
          
              <a  class="mdl-navigation__link" href="https://www.d2l.ai/">
                  <i class="fas fa-external-link-alt"></i>
                  English
              </a>
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text-vi.png" alt="Đắm mình vào Học Sâu"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro_vn.html">Giới thiệu từ nhóm dịch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preface/index_vn.html">Lời nói đầu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_install/index_vn.html">Cài đặt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_notation/index_vn.html">Ký hiệu</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter_introduction/index_vn.html">1. Giới thiệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preliminaries/index_vn.html">2. Sơ bộ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/ndarray_vn.html">2.1. Thao tác với Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/pandas_vn.html">2.2. Tiền xử lý dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/linear-algebra_vn.html">2.3. Đại số tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/calculus_vn.html">2.4. Giải tích</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/autograd_vn.html">2.5. Tính vi phân Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/probability_vn.html">2.6. Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/lookup-api_vn.html">2.7. Tài liệu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_linear-networks/index_vn.html">3. Mạng nơ-ron Tuyến tính</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression_vn.html">3.1. Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-scratch_vn.html">3.2. Lập trình Hồi quy Tuyến tính từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-gluon_vn.html">3.3. Cách lập trình súc tích Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression_vn.html">3.4. Hồi quy Softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/fashion-mnist_vn.html">3.5. Bộ dữ liệu Phân loại Ảnh (Fashion-MNIST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-scratch_vn.html">3.6. Lập trình Hồi quy Sofmax từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-gluon_vn.html">3.7. Cách lập trình súc tích Hồi quy Softmax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_multilayer-perceptrons/index_vn.html">4. Perceptron Đa tầng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp_vn.html">4.1. Perceptron đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-scratch_vn.html">4.2. Lập trình Perceptron Đa tầng từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-gluon_vn.html">4.3. Cách lập trình súc tích Perceptron Đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/underfit-overfit_vn.html">4.4. Lựa Chọn Mô Hình, Dưới Khớp và Quá Khớp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/weight-decay_vn.html">4.5. Suy giảm trọng số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/dropout_vn.html">4.6. Dropout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/backprop_vn.html">4.7. Lan truyền xuôi, Lan truyền ngược và Đồ thị tính toán</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/numerical-stability-and-init_vn.html">4.8. Ổn định Số học và Khởi tạo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/environment_vn.html">4.9. Cân nhắc tới Môi trường</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/kaggle-house-price_vn.html">4.10. Dự đoán Giá Nhà trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_deep-learning-computation/index_vn.html">5. Tính toán Học sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/model-construction_vn.html">5.1. Tầng và Khối</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/parameters_vn.html">5.2. Quản lý Tham số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/deferred-init_vn.html">5.3. Khởi tạo trễ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/custom-layer_vn.html">5.4. Các tầng Tuỳ chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/read-write_vn.html">5.5. Đọc/Ghi tệp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/use-gpu_vn.html">5.6. GPU</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_convolutional-neural-networks/index_vn.html">6. Mạng Nơ-ron Tích chập</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/why-conv_vn.html">6.1. Từ Tầng Kết nối Dày đặc đến phép Tích chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/conv-layer_vn.html">6.2. Phép Tích chập cho Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/padding-and-strides_vn.html">6.3. Đệm và Sải Bước</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/channels_vn.html">6.4. Đa kênh Đầu vào và Đầu ra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/pooling_vn.html">6.5. Gộp (<em>Pooling</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/lenet_vn.html">6.6. Mạng Nơ-ron Tích chập (LeNet)</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index_vn.html">7. Mạng Nơ-ron Tích chập Hiện đại</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="alexnet_vn.html">7.1. Mạng Nơ-ron Tích chập Sâu (AlexNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgg_vn.html">7.2. Mạng sử dụng Khối (VGG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="nin_vn.html">7.3. Mạng trong Mạng (<em>Network in Network - NiN</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="googlenet_vn.html">7.4. Mạng nối song song (GoogLeNet)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">7.5. Chuẩn hoá theo batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="resnet_vn.html">7.6. Mạng phần dư (ResNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="densenet_vn.html">7.7. Mạng Tích chập Kết nối Dày đặc (DenseNet)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-neural-networks/index_vn.html">8. Mạng Nơ-ron Hồi tiếp</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/sequence_vn.html">8.1. Mô hình chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/text-preprocessing_vn.html">8.2. Tiền Xử lý Dữ liệu Văn bản</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/language-models-and-dataset_vn.html">8.3. Mô hình Ngôn ngữ và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn_vn.html">8.4. Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-scratch_vn.html">8.5. Lập trình Mạng nơ-ron Hồi tiếp từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-gluon_vn.html">8.6. Lập trình súc tích Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/bptt_vn.html">8.7. Lan truyền Ngược qua Thời gian</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-modern/index_vn.html">9. Mạng Nơ-ron Hồi tiếp Hiện đại</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/gru_vn.html">9.1. Nút Hồi tiếp có Cổng (GRU)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/lstm_vn.html">9.2. Bộ nhớ Ngắn hạn Dài (LSTM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/deep-rnn_vn.html">9.3. Mạng Nơ-ron Hồi tiếp Sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/bi-rnn_vn.html">9.4. Mạng Nơ-ron Hồi tiếp Hai chiều</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/machine-translation-and-dataset_vn.html">9.5. Dịch Máy và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/encoder-decoder_vn.html">9.6. Kiến trúc Mã hoá - Giải mã</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/seq2seq_vn.html">9.7. Chuỗi sang Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/beam-search_vn.html">9.8. Tìm kiếm Chùm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_attention-mechanisms/index_vn.html">10. Cơ chế Tập trung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/attention_vn.html">10.1. Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/seq2seq-attention_vn.html">10.2. Chuỗi sang Chuỗi áp dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/transformer_vn.html">10.3. Kiến trúc Transformer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_optimization/index_vn.html">11. Thuật toán Tối ưu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html">11.1. Tối ưu và Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-thach-thuc-cua-toi-uu-trong-hoc-sau">11.2. Các Thách thức của Tối ưu trong Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-vung-cuc-tieu">11.3. Các vùng Cực tiểu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-diem-yen-ngua">11.4. Các điểm Yên ngựa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#tieu-bien-gradient">11.5. Tiêu biến Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/convexity_vn.html">11.6. Tính lồi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/gd_vn.html">11.7. Hạ Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/sgd_vn.html">11.8. Hạ Gradient Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/minibatch-sgd_vn.html">11.9. Hạ Gradient Ngẫu nhiên theo Minibatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/momentum_vn.html">11.10. Động lượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adagrad_vn.html">11.11. Adagrad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/rmsprop_vn.html">11.12. RMSProp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adadelta_vn.html">11.13. Adadelta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adam_vn.html">11.14. Adam</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/lr-scheduler_vn.html">11.15. Định thời Tốc độ Học</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_computational-performance/index_vn.html">12. Hiệu năng Tính toán</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hybridize_vn.html">12.1. Trình biên dịch và Trình thông dịch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/async-computation_vn.html">12.2. Tính toán Bất đồng bộ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/auto-parallelism_vn.html">12.3. Song song hóa Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hardware_vn.html">12.4. Phần cứng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus_vn.html">12.5. Huấn luyện đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus-concise_vn.html">12.6. Cách lập trình Súc tích đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/parameterserver_vn.html">12.7. Máy chủ Tham số</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_computer-vision/index_vn.html">13. Thị giác Máy tính</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/image-augmentation_vn.html">13.1. Tăng cường Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/fine-tuning_vn.html">13.2. Tinh Chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/bounding-box_vn.html">13.3. Phát hiện Vật thể và Khoanh vùng Đối tượng (Khung chứa)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/anchor_vn.html">13.4. Khung neo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/multiscale-object-detection_vn.html">13.5. Phát hiện Vật thể Đa tỷ lệ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/object-detection-dataset_vn.html">13.6. Tập dữ liệu Phát hiện Đối tượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/ssd_vn.html">13.7. Phát hiện Nhiều khung Một lượt (SSD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/rcnn_vn.html">13.8. CNN theo Vùng (R-CNN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/semantic-segmentation-and-dataset_vn.html">13.9. Phân vùng theo Ngữ nghĩa và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/transposed-conv_vn.html">13.10. Tích chập Chuyển vị</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/fcn_vn.html">13.11. Mạng Tích chập Đầy đủ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/neural-style_vn.html">13.12. Truyền tải Phong cách Nơ-ron</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/kaggle-cifar10_vn.html">13.13. Phân loại ảnh (CIFAR-10) trên Kaggle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/kaggle-dog_vn.html">13.14. Nhận diện Giống Chó (ImageNet Dogs) trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/index_vn.html">14. Xử lý Ngôn ngữ Tự nhiên: Tiền Huấn luyện</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec_vn.html">14.1. Embedding Từ (word2vec)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/approx-training_vn.html">14.2. Huấn luyện Gần đúng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word-embedding-dataset_vn.html">14.3. Tập dữ liệu để Tiền Huấn luyện Embedding Từ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec-pretraining_vn.html">14.4. Tiền huấn luyện word2vec</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/glove_vn.html">14.5. Embedding từ với Vector Toàn cục (GloVe)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/subword-embedding_vn.html">14.6. Embedding từ con</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/similarity-analogy_vn.html">14.7. Tìm kiếm từ Đồng nghĩa và Loại suy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert_vn.html">14.8. Biểu diễn Mã hóa hai chiều từ Transformer (BERT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-dataset_vn.html">14.9. Tập dữ liệu để Tiền huấn luyện BERT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-pretraining_vn.html">14.10. Tiền Huấn luyện BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-applications/index_vn.html">15. Xử lý Ngôn ngữ Tự nhiên: Ứng dụng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-and-dataset_vn.html">15.1. Tác vụ Phân tích Cảm xúc và Bộ Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-rnn_vn.html">15.2. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-cnn_vn.html">15.3. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Tích Chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-and-dataset_vn.html">15.4. Suy luận ngôn ngữ tự nhiên và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-attention_vn.html">15.5. Suy luận Ngôn ngữ Tự nhiên: Sử dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/finetuning-bert_vn.html">15.6. Tinh chỉnh BERT cho các Ứng dụng Cấp Chuỗi và Cấp Token</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-bert_vn.html">15.7. Suy luận Ngôn ngữ Tự nhiên: Tinh chỉnh BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recommender-systems/index_vn.html">16. Hệ thống Đề xuất</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/recsys-intro_vn.html">16.1. Tổng quan về Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/movielens_vn.html">16.2. Tập dữ liệu MovieLens</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/mf_vn.html">16.3. Phân rã Ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/autorec_vn.html">16.4. AutoRec: Dự đoán Đánh giá với Bộ tự Mã hóa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ranking_vn.html">16.5. Cá nhân hóa Xếp hạng trong Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/neumf_vn.html">16.6. Lọc Cộng tác Nơ-ron cho Cá nhân hóa Xếp hạng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/seqrec_vn.html">16.7. Hệ thống Đề xuất có Nhận thức về Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ctr_vn.html">16.8. Hệ thống Đề xuất Giàu Đặc trưng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/fm_vn.html">16.9. Máy Phân rã ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/deepfm_vn.html">16.10. Máy Phân rã Ma trận Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_generative-adversarial-networks/index_vn.html">17. Mạng Đối sinh</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/gan_vn.html">17.1. Mạng Đối sinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/dcgan_vn.html">17.2. Mạng Đối sinh Tích chập Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/index_vn.html">18. Phụ lục: Toán học cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/geometry-linear-algebraic-ops_vn.html">18.1. Các phép toán Hình học và Đại số Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/eigendecomposition_vn.html">18.2. Phân rã trị riêng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/single-variable-calculus_vn.html">18.3. Giải tích một biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/multivariable-calculus_vn.html">18.4. Giải tích Nhiều biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/integral-calculus_vn.html">18.5. Giải tích Tích phân</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/random-variables_vn.html">18.6. Biến Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/maximum-likelihood_vn.html">18.7. Hợp lý Cực đại</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/distributions_vn.html">18.8. Các Phân phối Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/naive-bayes_vn.html">18.9. Bộ phân loại Naive Bayes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/statistics_vn.html">18.10. Thống kê</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/information-theory_vn.html">18.11. Lý thuyết Thông tin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/index_vn.html">19. Phụ lục: Công cụ cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/jupyter_vn.html">19.1. Sử dụng Jupyter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/sagemaker_vn.html">19.2. Sử dụng Amazon SageMaker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/aws_vn.html">19.3. Sử dụng Máy ảo AWS EC2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/colab_vn.html">19.4. Sử dụng Google Colab</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/selecting-servers-gpus_vn.html">19.5. Lựa chọn Máy chủ &amp; GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/contributing_vn.html">19.6. Đóng góp cho Quyển sách</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/d2l_vn.html">19.7. Tài liệu API của <code class="docutils literal notranslate"><span class="pre">d2l</span></code></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapter_references/zreferences.html">Tài liệu tham khảo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Bảng thuật ngữ</a></li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">

	<script type="text/javascript" src="../_static/sphinx_materialdesign_theme.js "></script>
    <header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text-vi.png" alt="Đắm mình vào Học Sâu"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro_vn.html">Giới thiệu từ nhóm dịch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preface/index_vn.html">Lời nói đầu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_install/index_vn.html">Cài đặt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_notation/index_vn.html">Ký hiệu</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter_introduction/index_vn.html">1. Giới thiệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preliminaries/index_vn.html">2. Sơ bộ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/ndarray_vn.html">2.1. Thao tác với Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/pandas_vn.html">2.2. Tiền xử lý dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/linear-algebra_vn.html">2.3. Đại số tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/calculus_vn.html">2.4. Giải tích</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/autograd_vn.html">2.5. Tính vi phân Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/probability_vn.html">2.6. Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/lookup-api_vn.html">2.7. Tài liệu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_linear-networks/index_vn.html">3. Mạng nơ-ron Tuyến tính</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression_vn.html">3.1. Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-scratch_vn.html">3.2. Lập trình Hồi quy Tuyến tính từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-gluon_vn.html">3.3. Cách lập trình súc tích Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression_vn.html">3.4. Hồi quy Softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/fashion-mnist_vn.html">3.5. Bộ dữ liệu Phân loại Ảnh (Fashion-MNIST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-scratch_vn.html">3.6. Lập trình Hồi quy Sofmax từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-gluon_vn.html">3.7. Cách lập trình súc tích Hồi quy Softmax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_multilayer-perceptrons/index_vn.html">4. Perceptron Đa tầng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp_vn.html">4.1. Perceptron đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-scratch_vn.html">4.2. Lập trình Perceptron Đa tầng từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-gluon_vn.html">4.3. Cách lập trình súc tích Perceptron Đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/underfit-overfit_vn.html">4.4. Lựa Chọn Mô Hình, Dưới Khớp và Quá Khớp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/weight-decay_vn.html">4.5. Suy giảm trọng số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/dropout_vn.html">4.6. Dropout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/backprop_vn.html">4.7. Lan truyền xuôi, Lan truyền ngược và Đồ thị tính toán</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/numerical-stability-and-init_vn.html">4.8. Ổn định Số học và Khởi tạo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/environment_vn.html">4.9. Cân nhắc tới Môi trường</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/kaggle-house-price_vn.html">4.10. Dự đoán Giá Nhà trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_deep-learning-computation/index_vn.html">5. Tính toán Học sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/model-construction_vn.html">5.1. Tầng và Khối</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/parameters_vn.html">5.2. Quản lý Tham số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/deferred-init_vn.html">5.3. Khởi tạo trễ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/custom-layer_vn.html">5.4. Các tầng Tuỳ chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/read-write_vn.html">5.5. Đọc/Ghi tệp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/use-gpu_vn.html">5.6. GPU</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_convolutional-neural-networks/index_vn.html">6. Mạng Nơ-ron Tích chập</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/why-conv_vn.html">6.1. Từ Tầng Kết nối Dày đặc đến phép Tích chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/conv-layer_vn.html">6.2. Phép Tích chập cho Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/padding-and-strides_vn.html">6.3. Đệm và Sải Bước</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/channels_vn.html">6.4. Đa kênh Đầu vào và Đầu ra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/pooling_vn.html">6.5. Gộp (<em>Pooling</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/lenet_vn.html">6.6. Mạng Nơ-ron Tích chập (LeNet)</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index_vn.html">7. Mạng Nơ-ron Tích chập Hiện đại</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="alexnet_vn.html">7.1. Mạng Nơ-ron Tích chập Sâu (AlexNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgg_vn.html">7.2. Mạng sử dụng Khối (VGG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="nin_vn.html">7.3. Mạng trong Mạng (<em>Network in Network - NiN</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="googlenet_vn.html">7.4. Mạng nối song song (GoogLeNet)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">7.5. Chuẩn hoá theo batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="resnet_vn.html">7.6. Mạng phần dư (ResNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="densenet_vn.html">7.7. Mạng Tích chập Kết nối Dày đặc (DenseNet)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-neural-networks/index_vn.html">8. Mạng Nơ-ron Hồi tiếp</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/sequence_vn.html">8.1. Mô hình chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/text-preprocessing_vn.html">8.2. Tiền Xử lý Dữ liệu Văn bản</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/language-models-and-dataset_vn.html">8.3. Mô hình Ngôn ngữ và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn_vn.html">8.4. Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-scratch_vn.html">8.5. Lập trình Mạng nơ-ron Hồi tiếp từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-gluon_vn.html">8.6. Lập trình súc tích Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/bptt_vn.html">8.7. Lan truyền Ngược qua Thời gian</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-modern/index_vn.html">9. Mạng Nơ-ron Hồi tiếp Hiện đại</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/gru_vn.html">9.1. Nút Hồi tiếp có Cổng (GRU)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/lstm_vn.html">9.2. Bộ nhớ Ngắn hạn Dài (LSTM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/deep-rnn_vn.html">9.3. Mạng Nơ-ron Hồi tiếp Sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/bi-rnn_vn.html">9.4. Mạng Nơ-ron Hồi tiếp Hai chiều</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/machine-translation-and-dataset_vn.html">9.5. Dịch Máy và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/encoder-decoder_vn.html">9.6. Kiến trúc Mã hoá - Giải mã</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/seq2seq_vn.html">9.7. Chuỗi sang Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/beam-search_vn.html">9.8. Tìm kiếm Chùm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_attention-mechanisms/index_vn.html">10. Cơ chế Tập trung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/attention_vn.html">10.1. Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/seq2seq-attention_vn.html">10.2. Chuỗi sang Chuỗi áp dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/transformer_vn.html">10.3. Kiến trúc Transformer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_optimization/index_vn.html">11. Thuật toán Tối ưu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html">11.1. Tối ưu và Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-thach-thuc-cua-toi-uu-trong-hoc-sau">11.2. Các Thách thức của Tối ưu trong Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-vung-cuc-tieu">11.3. Các vùng Cực tiểu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-diem-yen-ngua">11.4. Các điểm Yên ngựa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#tieu-bien-gradient">11.5. Tiêu biến Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/convexity_vn.html">11.6. Tính lồi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/gd_vn.html">11.7. Hạ Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/sgd_vn.html">11.8. Hạ Gradient Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/minibatch-sgd_vn.html">11.9. Hạ Gradient Ngẫu nhiên theo Minibatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/momentum_vn.html">11.10. Động lượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adagrad_vn.html">11.11. Adagrad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/rmsprop_vn.html">11.12. RMSProp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adadelta_vn.html">11.13. Adadelta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adam_vn.html">11.14. Adam</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/lr-scheduler_vn.html">11.15. Định thời Tốc độ Học</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_computational-performance/index_vn.html">12. Hiệu năng Tính toán</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hybridize_vn.html">12.1. Trình biên dịch và Trình thông dịch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/async-computation_vn.html">12.2. Tính toán Bất đồng bộ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/auto-parallelism_vn.html">12.3. Song song hóa Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hardware_vn.html">12.4. Phần cứng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus_vn.html">12.5. Huấn luyện đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus-concise_vn.html">12.6. Cách lập trình Súc tích đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/parameterserver_vn.html">12.7. Máy chủ Tham số</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_computer-vision/index_vn.html">13. Thị giác Máy tính</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/image-augmentation_vn.html">13.1. Tăng cường Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/fine-tuning_vn.html">13.2. Tinh Chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/bounding-box_vn.html">13.3. Phát hiện Vật thể và Khoanh vùng Đối tượng (Khung chứa)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/anchor_vn.html">13.4. Khung neo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/multiscale-object-detection_vn.html">13.5. Phát hiện Vật thể Đa tỷ lệ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/object-detection-dataset_vn.html">13.6. Tập dữ liệu Phát hiện Đối tượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/ssd_vn.html">13.7. Phát hiện Nhiều khung Một lượt (SSD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/rcnn_vn.html">13.8. CNN theo Vùng (R-CNN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/semantic-segmentation-and-dataset_vn.html">13.9. Phân vùng theo Ngữ nghĩa và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/transposed-conv_vn.html">13.10. Tích chập Chuyển vị</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/fcn_vn.html">13.11. Mạng Tích chập Đầy đủ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/neural-style_vn.html">13.12. Truyền tải Phong cách Nơ-ron</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/kaggle-cifar10_vn.html">13.13. Phân loại ảnh (CIFAR-10) trên Kaggle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computer-vision/kaggle-dog_vn.html">13.14. Nhận diện Giống Chó (ImageNet Dogs) trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/index_vn.html">14. Xử lý Ngôn ngữ Tự nhiên: Tiền Huấn luyện</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec_vn.html">14.1. Embedding Từ (word2vec)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/approx-training_vn.html">14.2. Huấn luyện Gần đúng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word-embedding-dataset_vn.html">14.3. Tập dữ liệu để Tiền Huấn luyện Embedding Từ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec-pretraining_vn.html">14.4. Tiền huấn luyện word2vec</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/glove_vn.html">14.5. Embedding từ với Vector Toàn cục (GloVe)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/subword-embedding_vn.html">14.6. Embedding từ con</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/similarity-analogy_vn.html">14.7. Tìm kiếm từ Đồng nghĩa và Loại suy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert_vn.html">14.8. Biểu diễn Mã hóa hai chiều từ Transformer (BERT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-dataset_vn.html">14.9. Tập dữ liệu để Tiền huấn luyện BERT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-pretraining_vn.html">14.10. Tiền Huấn luyện BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-applications/index_vn.html">15. Xử lý Ngôn ngữ Tự nhiên: Ứng dụng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-and-dataset_vn.html">15.1. Tác vụ Phân tích Cảm xúc và Bộ Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-rnn_vn.html">15.2. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-cnn_vn.html">15.3. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Tích Chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-and-dataset_vn.html">15.4. Suy luận ngôn ngữ tự nhiên và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-attention_vn.html">15.5. Suy luận Ngôn ngữ Tự nhiên: Sử dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/finetuning-bert_vn.html">15.6. Tinh chỉnh BERT cho các Ứng dụng Cấp Chuỗi và Cấp Token</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-bert_vn.html">15.7. Suy luận Ngôn ngữ Tự nhiên: Tinh chỉnh BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recommender-systems/index_vn.html">16. Hệ thống Đề xuất</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/recsys-intro_vn.html">16.1. Tổng quan về Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/movielens_vn.html">16.2. Tập dữ liệu MovieLens</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/mf_vn.html">16.3. Phân rã Ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/autorec_vn.html">16.4. AutoRec: Dự đoán Đánh giá với Bộ tự Mã hóa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ranking_vn.html">16.5. Cá nhân hóa Xếp hạng trong Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/neumf_vn.html">16.6. Lọc Cộng tác Nơ-ron cho Cá nhân hóa Xếp hạng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/seqrec_vn.html">16.7. Hệ thống Đề xuất có Nhận thức về Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ctr_vn.html">16.8. Hệ thống Đề xuất Giàu Đặc trưng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/fm_vn.html">16.9. Máy Phân rã ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/deepfm_vn.html">16.10. Máy Phân rã Ma trận Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_generative-adversarial-networks/index_vn.html">17. Mạng Đối sinh</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/gan_vn.html">17.1. Mạng Đối sinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/dcgan_vn.html">17.2. Mạng Đối sinh Tích chập Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/index_vn.html">18. Phụ lục: Toán học cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/geometry-linear-algebraic-ops_vn.html">18.1. Các phép toán Hình học và Đại số Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/eigendecomposition_vn.html">18.2. Phân rã trị riêng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/single-variable-calculus_vn.html">18.3. Giải tích một biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/multivariable-calculus_vn.html">18.4. Giải tích Nhiều biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/integral-calculus_vn.html">18.5. Giải tích Tích phân</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/random-variables_vn.html">18.6. Biến Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/maximum-likelihood_vn.html">18.7. Hợp lý Cực đại</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/distributions_vn.html">18.8. Các Phân phối Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/naive-bayes_vn.html">18.9. Bộ phân loại Naive Bayes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/statistics_vn.html">18.10. Thống kê</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/information-theory_vn.html">18.11. Lý thuyết Thông tin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/index_vn.html">19. Phụ lục: Công cụ cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/jupyter_vn.html">19.1. Sử dụng Jupyter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/sagemaker_vn.html">19.2. Sử dụng Amazon SageMaker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/aws_vn.html">19.3. Sử dụng Máy ảo AWS EC2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/colab_vn.html">19.4. Sử dụng Google Colab</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/selecting-servers-gpus_vn.html">19.5. Lựa chọn Máy chủ &amp; GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/contributing_vn.html">19.6. Đóng góp cho Quyển sách</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/d2l_vn.html">19.7. Tài liệu API của <code class="docutils literal notranslate"><span class="pre">d2l</span></code></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapter_references/zreferences.html">Tài liệu tham khảo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Bảng thuật ngữ</a></li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content" role="main">
        
  <!-- ===================== Bắt đầu dịch Phần 1 ==================== --><!-- ========================================= REVISE PHẦN 1 - BẮT ĐẦU =================================== --><!--
# Batch Normalization
--><div class="section" id="chuan-hoa-theo-batch">
<span id="sec-batch-norm"></span><h1><span class="section-number">7.5. </span>Chuẩn hoá theo batch<a class="headerlink" href="#chuan-hoa-theo-batch" title="Permalink to this headline">¶</a></h1>
<!--
Training deep neural nets is difficult.
And getting them to converge in a reasonable amount of time can be tricky.
In this section, we describe batch normalization (BN) :cite:`Ioffe.Szegedy.2015`, a popular and effective technique that consistently accelerates the convergence of deep nets.
Together with residual blocks—covered in :numref:`sec_resnet`—BN has made it possible for practitioners to routinely train networks with over 100 layers.
--><p>Huấn luyện mạng nơ-ron sâu không hề đơn giản, để chúng hội tụ trong
khoảng thời gian chấp nhận được là một câu hỏi khá hóc búa. Trong phần
này, chúng ta giới thiệu chuẩn hóa theo batch (<em>Batch Normalization -
BN</em>) <a class="bibtex reference internal" href="../chapter_references/zreferences.html#ioffe-szegedy-2015" id="id1">[Ioffe &amp; Szegedy, 2015]</a>, một kỹ thuật phổ biến và hiệu quả
nhằm tăng tốc độ hội tụ của mạng học sâu một cách ổn định. Cùng với các
khối phần dư (<em>residual block</em>) được đề cập ở <a class="reference internal" href="resnet_vn.html#sec-resnet"><span class="std std-numref">Section 7.6</span></a> —
BN giúp dễ dàng hơn trong việc huấn luyện mạng học sâu với hơn 100 tầng.</p>
<!--
## Training Deep Networks
--><div class="section" id="huan-luyen-mang-hoc-sau">
<h2><span class="section-number">7.5.1. </span>Huấn luyện mạng học sâu<a class="headerlink" href="#huan-luyen-mang-hoc-sau" title="Permalink to this headline">¶</a></h2>
<!--
To motivate batch normalization, let us review a few practical challenges that arise
when training ML models and neural nets in particular.
--><p>Để thấy mục đích của việc chuẩn hóa theo batch, hãy cùng xem xét lại một
vài vấn đề phát sinh trên thực tế khi huấn luyện các mô hình học máy và
đặc biệt là mạng nơ-ron.</p>
<!--
1. Choices regarding data preprocessing often make an enormous difference in the final results.
Recall our application of multilayer perceptrons to predicting house prices (:numref:`sec_kaggle_house`).
Our first step when working with real data was to standardize our input features to each have a mean of *zero* and variance of *one*.
Intuitively, this standardization plays nicely with our optimizers because it puts the  parameters are a-priori at a similar scale.
2. For a typical MLP or CNN, as we train, the activations in intermediate layers may take values with widely varying magnitudes—both
along the layers from the input to the output, across nodes in the same layer, and over time due to our updates to the model's parameters.
The inventors of batch normalization postulated informally that this drift in the distribution of activations could hamper the convergence of the network.
Intuitively, we might conjecture that if one layer has activation values that are 100x that of another layer, this might necessitate compensatory adjustments in the learning rates.
3. Deeper networks are complex and easily capable of overfitting.
This means that regularization becomes more critical.
--><ol class="arabic simple">
<li>Những lựa chọn tiền xử lý dữ liệu khác nhau thường tạo nên sự khác
biệt rất lớn trong kết quả cuối cùng. Hãy nhớ lại việc áp dụng
perceptron đa tầng để dự đoán giá nhà (<a class="reference internal" href="../chapter_multilayer-perceptrons/kaggle-house-price_vn.html#sec-kaggle-house"><span class="std std-numref">Section 4.10</span></a>).
Việc đầu tiên khi làm việc với dữ liệu thực tế là chuẩn hóa các đặc
trưng đầu vào để chúng có giá trị trung bình bằng <em>không</em> và phương
sai bằng <em>một</em>. Thông thường, việc chuẩn hóa này hoạt động tốt với
các bộ tối ưu vì giá trị các tham số tiên nghiệm có cùng một khoảng
tỷ lệ.</li>
<li>Khi huấn luyện các mạng thường gặp như Perceptron đa tầng hay CNN,
các giá trị kích hoạt ở các tầng trung gian có thể nhận các giá trị
với mức độ biến thiên lớn- dọc theo các tầng từ đầu vào đến đầu ra,
qua các nút ở cùng một tầng, và theo thời gian do việc cập nhật giá
trị tham số. Những nhà phát minh kỹ thuật chuẩn hoá theo batch cho
rằng sự thay đổi trong phân phối của những giá trị kích hoạt có thể
cản trở sự hội tụ của mạng. Dễ thấy rằng nếu một tầng có các giá trị
kích hoạt lớn gấp 100 lần so với các tầng khác, thì cần phải có các
điều chỉnh bổ trợ trong tốc độ học.</li>
<li>Mạng nhiều tầng có độ phức tạp cao và dễ gặp vấn đề quá khớp. Điều
này cũng đồng nghĩa rằng kỹ thuật điều chuẩn càng trở nên quan trọng.</li>
</ol>
<!-- ===================== Kết thúc dịch Phần 1 ===================== --><!-- ===================== Bắt đầu dịch Phần 2 ===================== --><!--
Batch normalization is applied to individual layers (optionally, to all of them) and works as follows:
In each training iteration, for each layer, we first compute its activations as usual.
Then, we normalize the activations of each node by subtracting its mean and dividing by its standard deviation
estimating both quantities based on the statistics of the current the current minibatch.
It is precisely due to this *normalization* based on *batch* statistics that *batch normalization* derives its name.
--><p>Chuẩn hoá theo batch được áp dụng cho từng tầng riêng lẻ (hoặc có thể
cho tất cả các tầng) và hoạt động như sau: Trong mỗi vòng lặp huấn
luyện, tại mỗi tầng, đầu tiên tính giá trị kích hoạt như thường lệ. Sau
đó chuẩn hóa những giá trị kích hoạt của mỗi nút bằng việc trừ đi giá
trị trung bình và chia cho độ lệch chuẩn. Cả hai đại lượng này được ước
tính dựa trên số liệu thống kê của minibatch hiện tại. Chính vì <em>chuẩn
hóa</em> dựa trên các số liệu thống kê của <em>batch</em> nên kỹ thuật này có tên
gọi <em>chuẩn hoá theo batch</em>.</p>
<!--
Note that if we tried to apply BN with minibatches of size $1$, we would not be able to learn anything.
That is because after subtracting the means, each hidden node would take value $0$!
As you might guess, since we are devoting a whole section to BN, with large enough minibatches, the approach proves effective and stable.
One takeaway here is that when applying BN, the choice of minibatch size may be even more significant than without BN.
--><p>Lưu ý rằng, khi áp dụng BN với những minibatch có kích thước 1, mô hình
sẽ không học được gì. Vì sau khi trừ đi giá trị trung bình, mỗi nút ẩn
sẽ nhận giá trị <span class="math notranslate nohighlight">\(0\)</span>! Dễ dàng suy luận ra là BN chỉ hoạt động hiệu
quả và ổn định với kích thước minibatch đủ lớn. Cần ghi nhớ rằng, khi áp
dụng BN là lựa chọn kích thước minibatch quan trọng hơn so với trường
hợp không áp dụng BN.</p>
<!--
Formally, BN transforms the activations at a given layer $\mathbf{x}$ according to the following expression:
--><p>BN chuyển đổi những giá trị kích hoạt tại tầng <span class="math notranslate nohighlight">\(x\)</span> nhất định theo
công thức sau:</p>
<div class="math notranslate nohighlight" id="equation-chapter-convolutional-modern-batch-norm-vn-0">
<span class="eqno">(7.5.1)<a class="headerlink" href="#equation-chapter-convolutional-modern-batch-norm-vn-0" title="Permalink to this equation">¶</a></span>\[\mathrm{BN}(\mathbf{x}) = \mathbf{\gamma} \odot \frac{\mathbf{x} - \hat{\mathbf{\mu}}}{\hat\sigma} + \mathbf{\beta}\]</div>
<!--
Here, $\hat{\mathbf{\mu}}$ is the minibatch sample mean and $\hat{\mathbf{\sigma}}$ is the minibatch sample variance.
After applying BN, the resulting minibatch of activations has zero mean and unit variance.
Because the choice of unit variance (vs some other magic number) is an arbitrary choice,
we commonly include coordinate-wise scaling coefficients $\mathbf{\gamma}$ and offsets $\mathbf{\beta}$.
Consequently, the activation magnitudes for intermediate layers cannot diverge during training
because BN actively centers and rescales them back to a given mean and size (via $\mathbf{\mu}$ and $\sigma$).
One piece of practitioner's intuition/wisdom is that BN seems to allows for more aggressive learning rates.
--><p>Ở đây, <span class="math notranslate nohighlight">\(\hat{\mathbf{\mu}}\)</span> là giá trị trung bình và
<span class="math notranslate nohighlight">\(\hat{\mathbf{\sigma}}\)</span> là độ lệch chuẩn của các mẫu trong
minibatch. Sau khi áp dụng BN, những giá trị kích hoạt của minibatch có
giá trị trung bình bằng không và phương sai đơn vị. Vì việc lựa chọn
phương sai đơn vị (so với một giá trị đặc biệt khác) là tuỳ ý, nên chúng
ta thường thêm vào từng cặp tham số tương ứng là hệ số tỷ lệ
<span class="math notranslate nohighlight">\(\mathbf{\gamma}\)</span> và độ chệch <span class="math notranslate nohighlight">\(\mathbf{\beta}\)</span>. Do đó, độ
lớn giá trị kích hoạt ở những tầng trung gian không thể phân kỳ trong
quá trình huấn luyện vì BN chủ động chuẩn hoá chúng theo giá trị trung
bình và phương sai cho trước (thông qua <span class="math notranslate nohighlight">\(\mathbf{\mu}\)</span> và
<span class="math notranslate nohighlight">\(\sigma\)</span>). Qua trực giác và thực nghiệm, dùng BN có thể cho phép
chọn tốc độ học nhanh hơn.</p>
<!-- ===================== Kết thúc dịch Phần 2 ===================== --><!-- ===================== Bắt đầu dịch Phần 3 ===================== --><!--
Formally, denoting a particular minibatch by $\mathcal{B}$,
we calculate $\hat{\mathbf{\mu}}_\mathcal{B}$ and $\hat\sigma_\mathcal{B}$ as follows:
--><p>Ký hiệu một minibatch là <span class="math notranslate nohighlight">\(\mathcal{B}\)</span>, chúng ta tính
<span class="math notranslate nohighlight">\(\hat{\mathbf{\mu}}_\mathcal{B}\)</span> và <span class="math notranslate nohighlight">\(\hat\sigma_\mathcal{B}\)</span>
theo công thức sau:</p>
<div class="math notranslate nohighlight" id="equation-chapter-convolutional-modern-batch-norm-vn-1">
<span class="eqno">(7.5.2)<a class="headerlink" href="#equation-chapter-convolutional-modern-batch-norm-vn-1" title="Permalink to this equation">¶</a></span>\[\hat{\mathbf{\mu}}_\mathcal{B} \leftarrow \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} \mathbf{x}
\text{ và }
\hat{\mathbf{\sigma}}_\mathcal{B}^2 \leftarrow \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \mathbf{\mu}_{\mathcal{B}})^2 + \epsilon\]</div>
<!--
Note that we add a small constant $\epsilon > 0$ to the variance estimate
to ensure that we never attempt division by zero, even in cases where the empirical variance estimate might vanish.
The estimates $\hat{\mathbf{\mu}}_\mathcal{B}$ and $\hat{\mathbf{\sigma}}_\mathcal{B}$ counteract the scaling issue by using noisy estimates of mean and variance.
You might think that this noisiness should be a problem.
As it turns out, this is actually beneficial.
--><p>Lưu ý rằng chúng ta thêm hằng số rất nhỏ <span class="math notranslate nohighlight">\(\epsilon &gt; 0\)</span> vào biểu
thức tính phương sai để đảm bảo tránh phép chia cho 0 khi chuẩn hoá,
ngay cả khi giá trị ước lượng phương sai thực nghiệm bằng không. Các ước
lượng <span class="math notranslate nohighlight">\(\hat{\mathbf{\mu}}_\mathcal{B}\)</span> và
<span class="math notranslate nohighlight">\(\hat{\mathbf{\sigma}}_\mathcal{B}\)</span> giúp đương đầu với vấn đề khi
cần mở rộng số tầng của mạng (mạng học sâu hơn) bằng việc sử dụng nhiễu
khi tính giá trị trung bình và phương sai. Bạn có thể nghĩ rằng nhiễu sẽ
là vấn đề đáng ngại. Nhưng thực ra, nhiễu lại đem đến lợi ích.</p>
<!--
This turns out to be a recurring theme in deep learning.
For reasons that are not yet well-characterized theoretically, various sources of noise in optimization often lead to faster training and less overfitting.
While traditional machine learning theorists might buckle at this characterization, this variation appears to act as a form of regularization.
In some preliminary research, :cite:`Teye.Azizpour.Smith.2018` and :cite:`Luo.Wang.Shao.ea.2018` relate the properties of BN to Bayesian Priors and penalties respectively.
In particular, this sheds some light on the puzzle of why BN works best for moderate minibatches sizes in the $50$–$100$ range.
--><p>Và đây là chủ đề thường xuất hiện trong học sâu. Vì những lý do vẫn chưa
được giải thích rõ bằng lý thuyết, nhiều nguồn nhiễu khác nhau trong
việc tối ưu hoá thường dẫn đến huấn luyện nhanh hơn và giảm quá khớp.
Trong khi những nhà lý thuyết học máy truyền thống có thể bị vướng mắc ở
việc định rõ điểm này, những thay đổi do nhiễu dường như hoạt động giống
một dạng điều chuẩn. Trong một số nghiên cứu sơ bộ,
<a class="bibtex reference internal" href="../chapter_references/zreferences.html#teye-azizpour-smith-2018" id="id2">[Teye et al., 2018]</a> và <a class="bibtex reference internal" href="../chapter_references/zreferences.html#luo-wang-shao-ea-2018" id="id3">[Luo et al., 2018]</a> đã
lần lượt chỉ ra các thuộc tính của BN liên quan tới tiên nghiệm Bayesian
(<em>Bayesian prior</em>) và các lượng phạt (<em>penalty</em>). Cụ thể, nghiên cứu này
làm sáng tỏ lý do BN hoạt động tốt nhất với các minibatch có kích cỡ vừa
phải, trong khoảng 50 - 100.</p>
<!--
Fixing a trained model, you might (rightly) think that we would prefer to use the entire dataset to estimate the mean and variance.
Once training is complete, why would we want the same image to be classified differently, depending on the batch in which it happens to reside?
During training, such exact calculation is infeasible because the activations for all data points change every time we update our model.
However, once the model is trained, we can calculate the means and variances of each layer's activations based on the entire dataset.
Indeed this is standard practice for models employing batch normalization and thus MXNet's BN layers function differently
in *training mode* (normalizing by minibatch statistics) and in *prediction mode* (normalizing by dataset statistics).
--><p>Cố định một mô hình đã được huấn luyện, bạn có thể nghĩ rằng chúng ta
nên sử dụng toàn bộ tập dữ liệu để ước tính giá trị trung bình và phương
sai. Và đúng là như vậy. Bởi lẽ khi huấn luyện xong, tại sao ta lại muốn
cùng một hình ảnh lại được phân loại khác nhau phụ thuộc vào batch chứa
hình ảnh này? Trong quá trình huấn luyện, những tính toán chính xác như
vậy không khả thi vì giá trị kích hoạt cho tất cả các điểm dữ liệu thay
đổi mỗi khi cập nhật mô hình. Tuy nhiên, một khi mô hình đã được huấn
luyện xong, chúng ta có thể tính được giá trị trung bình và phương sai
của mỗi tầng dựa trên toàn bộ tập dữ liệu. Thực ra đây là tiêu chuẩn
thực hành cho các mô hình sử dụng chuẩn hóa theo batch và do đó các tầng
BN của MXNet hoạt động khác nhau giữa <em>chế độ huấn luyện</em> (chuẩn hoá
bằng số liệu thống kê của minibatch) và <em>chế độ dự đoán</em> (chuẩn hoá bằng
số liệu thống kê của toàn bộ tập dữ liệu)</p>
<!--
We are now ready to take a look at how batch normalization works in practice.
--><p>Bây giờ chúng ta đã sẵn sàng để xem chuẩn hoá theo batch hoạt động thế
nào trong thực tế.</p>
<!-- ===================== Kết thúc dịch Phần 3 ===================== --><!-- ===================== Bắt đầu dịch Phần 4 ===================== --><!-- ========================================= REVISE PHẦN 1 - KẾT THÚC ===================================--><!-- ========================================= REVISE PHẦN 2 - BẮT ĐẦU ===================================--><!--
## Batch Normalization Layers
--></div>
<div class="section" id="tang-chuan-hoa-theo-batch">
<h2><span class="section-number">7.5.2. </span>Tầng chuẩn hoá theo batch<a class="headerlink" href="#tang-chuan-hoa-theo-batch" title="Permalink to this headline">¶</a></h2>
<!--
Batch normalization implementations for fully-connected layers and convolutional layers are slightly different.
We discuss both cases below.
Recall that one key differences between BN and other layers is that because BN operates on a full minibatch at a time,
 we cannot just ignore the batch dimension as we did before when introducing other layers.
--><p>Thực hiện việc chuẩn hóa theo batch cho tầng kết nối đầy đủ và tầng tích
chập hơi khác nhau một chút. Chúng ta sẽ thảo luận cả hai trường hợp
trên. Nhớ rằng một khác biệt lớn của BN so với những tầng khác là vì BN
cần số liệu thống kê trên toàn minibatch, chúng ta không thể bỏ qua kích
thước batch như đã làm với các tầng khác.</p>
<!--
### Fully-Connected Layers
--><div class="section" id="tang-ket-noi-day-du">
<h3><span class="section-number">7.5.2.1. </span>Tầng kết nối đầy đủ<a class="headerlink" href="#tang-ket-noi-day-du" title="Permalink to this headline">¶</a></h3>
<!--
When applying BN to fully-connected layers, we usually insert BN after the affine transformation and before the nonlinear activation function.
Denoting the input to the layer by $\mathbf{x}$, the linear transform (with weights $\theta$) by $f_{\theta}(\cdot)$,
the activation function by $\phi(\cdot)$, and the BN operation with parameters $\mathbf{\beta}$ and $\mathbf{\gamma}$ by $\mathrm{BN}_{\mathbf{\beta}, \mathbf{\gamma}}$,
we can express the computation of a BN-enabled, fully-connected layer $\mathbf{h}$ as follows:
--><p>Khi áp dụng BN cho tầng kết nối đầy đủ, ta thường chèn BN sau bước biến
đổi affine và trước hàm kích hoạt phi tuyến. Kí hiệu đầu vào của tầng là
<span class="math notranslate nohighlight">\(\mathbf{x}\)</span>, hàm biến đổi tuyến tính là <span class="math notranslate nohighlight">\(f_{\theta}(\cdot)\)</span>
(với trọng số là <span class="math notranslate nohighlight">\(\theta\)</span>), hàm kích hoạt là <span class="math notranslate nohighlight">\(\phi(\cdot)\)</span>,
và phép tính BN là <span class="math notranslate nohighlight">\(\mathrm{BN}_{\mathbf{\beta}, \mathbf{\gamma}}\)</span>
với tham số <span class="math notranslate nohighlight">\(\mathbf{\beta}\)</span> và <span class="math notranslate nohighlight">\(\mathbf{\gamma}\)</span>, chúng ta
sẽ biểu diễn việc tính toán tầng kết nối đầy đủ <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> khi
chèn lớp BN vào như sau:</p>
<div class="math notranslate nohighlight" id="equation-chapter-convolutional-modern-batch-norm-vn-2">
<span class="eqno">(7.5.3)<a class="headerlink" href="#equation-chapter-convolutional-modern-batch-norm-vn-2" title="Permalink to this equation">¶</a></span>\[\mathbf{h} = \phi(\mathrm{BN}_{\mathbf{\beta}, \mathbf{\gamma}}(f_{\mathbf{\theta}}(\mathbf{x}) ) )\]</div>
<!--
Recall that mean and variance are computed on the *same* minibatch $\mathcal{B}$ on which the transformation is applied.
Also recall that the scaling coefficient $\mathbf{\gamma}$ and the offset $\mathbf{\beta}$ are parameters that need to be learned jointly with the more familiar parameters $\mathbf{\theta}$.
--><p>Nhắc lại rằng giá trị trung bình và phương sai sẽ được tính toán trên
<em>chính</em> minibatch <span class="math notranslate nohighlight">\(\mathcal{B}\)</span> mà sẽ được biến đổi. Cũng cần lưu
ý rằng hệ số tỷ lệ <span class="math notranslate nohighlight">\(\mathbf{\gamma}\)</span> và độ chệch
<span class="math notranslate nohighlight">\(\mathbf{\beta}\)</span> là những tham số cần được học cùng với bộ tham số
quen thuộc <span class="math notranslate nohighlight">\(\mathbf{\theta}\)</span>.</p>
<!--
### Convolutional Layers
--></div>
<div class="section" id="tang-tich-chap">
<h3><span class="section-number">7.5.2.2. </span>Tầng tích chập<a class="headerlink" href="#tang-tich-chap" title="Permalink to this headline">¶</a></h3>
<!--
Similarly, with convolutional layers, we typically apply BN after the convolution and before the nonlinear activation function.
When the convolution has multiple output channels, we need to carry out batch normalization for *each* of the outputs of these channels,
and each channel has its own scale and shift parameters, both of which are scalars.
Assume that our minibatches contain $m$ each and that for each channel, the output of the convolution has height $p$ and width $q$.
For convolutional layers, we carry out each batch normalization over the $m \cdot p \cdot q$ elements per output channel simultaneously.
Thus we collect the values over all spatial locations when computing the mean and variance and consequently (within a given channel)
apply the same $\hat{\mathbf{\mu}}$ and $\hat{\mathbf{\sigma}}$ to normalize the values at each spatial location.
--><p>Tương tự với tầng tích chập, chúng ta áp dụng BN sau phép tích chập và
trước hàm kích hoạt phi tuyến. Khi áp dụng phép tích chập cho đầu ra
nhiều kênh, chúng ta cần thực hiện chuẩn hóa theo batch cho <em>mỗi</em> đầu ra
của những kênh này, và mỗi kênh sẽ có riêng cho nó các tham số tỉ lệ và
độ chệch, cả hai đều là các số vô hướng. Giả sử các minibatch có kích
thước <span class="math notranslate nohighlight">\(m\)</span>, đầu ra cho mỗi kênh của phép tích chập có chiều cao
<span class="math notranslate nohighlight">\(p\)</span> và chiều rộng <span class="math notranslate nohighlight">\(q\)</span>. Với tầng tích chập, ta sẽ thực hiện
mỗi phép chuẩn hoá theo batch trên <span class="math notranslate nohighlight">\(m \cdot p \cdot q\)</span> phần tử
trên từng kênh đầu ra cùng lúc. Vì thế trên từng kênh, ta sử dụng giá
trị trên tất cả các vị trí không gian để tính trung bình
<span class="math notranslate nohighlight">\(\hat{\mathbf{\mu}}\)</span> và phương sai <span class="math notranslate nohighlight">\(\hat{\mathbf{\sigma}}\)</span>
và sau đó dùng hai giá trị này để chuẩn hóa các giá trị tại mỗi vị trí
không gian trên kênh đó.</p>
<!-- ===================== Kết thúc dịch Phần 4 ===================== --><!-- ===================== Bắt đầu dịch Phần 5 ===================== --><!--
### Batch Normalization During Prediction
--></div>
<div class="section" id="chuan-hoa-theo-batch-trong-qua-trinh-du-doan">
<h3><span class="section-number">7.5.2.3. </span>Chuẩn hoá theo Batch trong Quá trình Dự đoán<a class="headerlink" href="#chuan-hoa-theo-batch-trong-qua-trinh-du-doan" title="Permalink to this headline">¶</a></h3>
<!--
As we mentioned earlier, BN typically behaves differently in training mode and prediction mode.
First, the noise in $\mathbf{\mu}$ and $\mathbf{\sigma}$ arising from estimating each on minibatches are no longer desirable once we have trained the model.
Second, we might not have the luxury of computing per-batch normalization statistics, e.g., we might need to apply our model to make one prediction at a time.
--><p>Như đã đề cập trước đó, BN thường hoạt động khác nhau trong chế độ huấn
luyện và chế độ dự đoán. Thứ nhất, nhiễu trong <span class="math notranslate nohighlight">\(\mu\)</span> và
<span class="math notranslate nohighlight">\(\sigma\)</span> phát sinh từ việc chúng được xấp xỉ trên các minibatch
không còn là nhiễu được mong muốn một khi ta đã huấn luyện xong mô hình.
Thứ hai, trong nhiều trường hợp sẽ là xa xỉ khi tính toán các con số
thống kê sau mỗi lần chuẩn hoá theo batch, ví dụ, khi cần áp dụng mô
hình để đưa ra một kết quả dự đoán mỗi lần.</p>
<!--
Typically, after training, we use the entire dataset to compute stable estimates of the activation statistics and then fix them at prediction time.
Consequently, BN behaves differently during training and at test time.
Recall that dropout also exhibits this characteristic.
--><p>Thông thường, sau khi huấn luyện, chúng ta sử dụng toàn bộ tập dữ liệu
để tính toán các con số thống kê của các giá trị kích hoạt và sau đó cố
định chúng tại thời điểm dự đoán. Do đó, BN hoạt động khác nhau trong
quá trình huấn luyện và kiểm tra. Lưu ý rằng dropout cũng có tính chất
này.</p>
<!-- ========================================= REVISE PHẦN 2 - KẾT THÚC ===================================--><!-- ========================================= REVISE PHẦN 3 - BẮT ĐẦU ===================================--><!--
## Implementation from Scratch
--></div>
</div>
<div class="section" id="lap-trinh-tu-dau">
<h2><span class="section-number">7.5.3. </span>Lập trình từ đầu<a class="headerlink" href="#lap-trinh-tu-dau" title="Permalink to this headline">¶</a></h2>
<!--
Below, we implement a batch normalization layer with `ndarray`s from scratch:
--><p>Dưới đây, chúng ta lập trình tầng chuẩn hoá theo batch chỉ dùng
<code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">d2l</span> <span class="kn">import</span> <span class="n">mxnet</span> <span class="k">as</span> <span class="n">d2l</span>
<span class="kn">from</span> <span class="nn">mxnet</span> <span class="kn">import</span> <span class="n">autograd</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">npx</span><span class="p">,</span> <span class="n">init</span>
<span class="kn">from</span> <span class="nn">mxnet.gluon</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="n">npx</span><span class="o">.</span><span class="n">set_np</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">batch_norm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">moving_mean</span><span class="p">,</span> <span class="n">moving_var</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">momentum</span><span class="p">):</span>
    <span class="c1"># Use autograd to determine whether the current mode is training mode or</span>
    <span class="c1"># prediction mode</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">autograd</span><span class="o">.</span><span class="n">is_training</span><span class="p">():</span>
        <span class="c1"># If it is the prediction mode, directly use the mean and variance</span>
        <span class="c1"># obtained from the incoming moving average</span>
        <span class="n">X_hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">moving_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">moving_var</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># When using a fully connected layer, calculate the mean and</span>
            <span class="c1"># variance on the feature dimension</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When using a two-dimensional convolutional layer, calculate the</span>
            <span class="c1"># mean and variance on the channel dimension (axis=1). Here we</span>
            <span class="c1"># need to maintain the shape of X, so that the broadcast operation</span>
            <span class="c1"># can be carried out later</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># In training mode, the current mean and variance are used for the</span>
        <span class="c1"># standardization</span>
        <span class="n">X_hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="c1"># Update the mean and variance of the moving average</span>
        <span class="n">moving_mean</span> <span class="o">=</span> <span class="n">momentum</span> <span class="o">*</span> <span class="n">moving_mean</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span> <span class="o">*</span> <span class="n">mean</span>
        <span class="n">moving_var</span> <span class="o">=</span> <span class="n">momentum</span> <span class="o">*</span> <span class="n">moving_var</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span> <span class="o">*</span> <span class="n">var</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">X_hat</span> <span class="o">+</span> <span class="n">beta</span>  <span class="c1"># Scale and shift</span>
    <span class="k">return</span> <span class="n">Y</span><span class="p">,</span> <span class="n">moving_mean</span><span class="p">,</span> <span class="n">moving_var</span>
</pre></div>
</div>
<!--
We can now create a proper `BatchNorm` layer.
Our layer will maintain proper parameters corresponding for scale `gamma` and shift `beta`, both of which will be updated in the course of training.
Additionally, our layer will maintain a moving average of the means and variances for subsequent use during model prediction.
The `num_features` parameter required by the `BatchNorm` instance is the number of outputs for a fully-connected layer and the number of output channels for a convolutional layer.
The `num_dims` parameter also required by this instance is 2 for a fully-connected layer and 4 for a convolutional layer.
--><p>Giờ ta có thể tạo một tầng <code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code> đúng cách. Tầng này sẽ duy trì
những tham số thích hợp tương ứng với tỉ lệ <code class="docutils literal notranslate"><span class="pre">gamma</span></code> và độ chệch
<code class="docutils literal notranslate"><span class="pre">beta</span></code>, hai tham số này sẽ được cập nhật trong quá trình huấn luyện.
Thêm vào đó, tầng BN sẽ duy trì giá trị trung bình động của trung bình
và phương sai để sử dụng về sau khi ở chế độ dự đoán. Tham số
<code class="docutils literal notranslate"><span class="pre">num_features</span></code> truyền vào <code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code> là số đầu ra của tầng kết nối
đầy đủ hoặc số kênh đầu ra của tầng tích chập. Tham số <code class="docutils literal notranslate"><span class="pre">num_dims</span></code> bằng
2 nếu là tầng kết nối đầy đủ và bằng 4 nếu là tầng tích chập.</p>
<!-- ===================== Kết thúc dịch Phần 5 ===================== --><!-- ===================== Bắt đầu dịch Phần 6 ===================== --><!--
Putting aside the algorithmic details, note the design pattern underlying our implementation of the layer.
Typically, we define the math in a separate function, say `batch_norm`.
We then integrate this functionality into a custom layer, whose code mostly addresses bookkeeping matters,
such as moving data to the right device context, allocating and initializing any required variables, keeping track of running averages (here for mean and variance), etc.
This pattern enables a clean separation of math from boilerplate code.
Also note that for the sake of convenience we did not worry about automatically inferring the input shape here, thus our need to specify the number of features throughout.
Do not worry, the Gluon `BatchNorm` layer will care of this for us.
--><p>Tạm để thuật toán sang một bên và tập trung vào khuôn mẫu thiết kế
(<em>design pattern</em>) của việc lập trình. Thông thường, ta lập trình phần
toán trong một hàm riêng biệt, ví dụ như <code class="docutils literal notranslate"><span class="pre">batch_norm</span></code>. Sau đó, ta tích
hợp chức năng này vào một tầng tùy chỉnh, với mã nguồn chủ yếu giải
quyết các vấn đề phụ trợ như di chuyển dữ liệu đến thiết bị phù hợp, cấp
phát và khởi tạo biến, theo dõi các giá trị trung bình động (của trung
bình và phương sai trong trường hợp này), v.v. Khuôn mẫu này giúp tách
biệt việc tính toán khỏi các đoạn mã rập khuôn. Cũng lưu ý rằng để thuận
tiện khi lập trình BN từ đầu, ta không tự động suy ra kích thước đầu
vào, do đó ta cần chỉ định số lượng đặc trưng xuyên suốt. Tầng
<code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code> của Gluon sẽ hỗ trợ việc tự động này bằng khởi tạo trễ.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BatchNorm</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Block</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BatchNorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># The scale parameter and the shift parameter involved in gradient</span>
        <span class="c1"># finding and iteration are initialized to 0 and 1 respectively</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="o">.</span><span class="n">One</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="o">.</span><span class="n">Zero</span><span class="p">())</span>
        <span class="c1"># All the variables not involved in gradient finding and iteration are</span>
        <span class="c1"># initialized to 0 on the CPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="c1"># If X is not on the CPU, copy moving_mean and moving_var to the</span>
        <span class="c1"># device where X is located</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_mean</span><span class="o">.</span><span class="n">ctx</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">ctx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moving_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_mean</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moving_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_var</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="c1"># Save the updated moving_mean and moving_var</span>
        <span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_var</span> <span class="o">=</span> <span class="n">batch_norm</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_mean</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moving_var</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Y</span>
</pre></div>
</div>
<!--
## Using a Batch Normalization LeNet
--></div>
<div class="section" id="su-dung-lenet-voi-chuan-hoa-theo-batch">
<h2><span class="section-number">7.5.4. </span>Sử dụng LeNet với Chuẩn hóa theo Batch<a class="headerlink" href="#su-dung-lenet-voi-chuan-hoa-theo-batch" title="Permalink to this headline">¶</a></h2>
<!--
To see how to apply `BatchNorm` in context, below we apply it to a traditional LeNet model (:numref:`sec_lenet`).
Recall that BN is typically applied after the convolutional layers and fully-connected layers but before the corresponding activation functions.
--><p>Để biết cách áp dụng <code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code> trên thực tế, bên dưới ta áp dụng cho
mô hình LeNet truyền thống (<a class="reference internal" href="../chapter_convolutional-neural-networks/lenet_vn.html#sec-lenet"><span class="std std-numref">Section 6.6</span></a>). Nhắc lại rằng BN
thường được sử dụng sau tầng tích chập và tầng kết nối đầy đủ và trước
hàm kích hoạt tương ứng.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">net</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">()</span>
<span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
        <span class="n">BatchNorm</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">num_dims</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
        <span class="n">BatchNorm</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">num_dims</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span>
        <span class="n">BatchNorm</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="n">num_dims</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">84</span><span class="p">),</span>
        <span class="n">BatchNorm</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="n">num_dims</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<!--
As before, we will train our network on the Fashion-MNIST dataset.
This code is virtually identical to that when we first trained LeNet (:numref:`sec_lenet`).
The main difference is the considerably larger learning rate.
--><p>Như thường lệ, ta sẽ huấn luyện trên bộ dữ liệu Fashion-MNIST. Đoạn mã
này gần tương tự với đoạn mã khi lần đầu huấn luyện LeNet
(<a class="reference internal" href="../chapter_convolutional-neural-networks/lenet_vn.html#sec-lenet"><span class="std std-numref">Section 6.6</span></a>). Điểm khác biệt chính là tốc độ học lớn hơn đáng
kể.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lr</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">256</span>
<span class="n">train_iter</span><span class="p">,</span> <span class="n">test_iter</span> <span class="o">=</span> <span class="n">d2l</span><span class="o">.</span><span class="n">load_data_fashion_mnist</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
<span class="n">d2l</span><span class="o">.</span><span class="n">train_ch6</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">train_iter</span><span class="p">,</span> <span class="n">test_iter</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">lr</span><span class="p">)</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">loss</span> <span class="mf">0.244</span><span class="p">,</span> <span class="n">train</span> <span class="n">acc</span> <span class="mf">0.909</span><span class="p">,</span> <span class="n">test</span> <span class="n">acc</span> <span class="mf">0.871</span>
<span class="mf">6812.0</span> <span class="n">examples</span><span class="o">/</span><span class="n">sec</span> <span class="n">on</span> <span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../_images/output_batch-norm_vn_e8f877_7_1.svg" src="../_images/output_batch-norm_vn_e8f877_7_1.svg" /></div>
<!--
Let us have a look at the scale parameter `gamma` and the shift parameter `beta` learned from the first batch normalization layer.
--><p>Chúng ta hãy xem tham số tỷ lệ <code class="docutils literal notranslate"><span class="pre">gamma</span></code> và tham số dịch chuyển <code class="docutils literal notranslate"><span class="pre">beta</span></code>
đã học được tại tầng chuẩn hóa theo batch đầu tiên.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">net</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="n">net</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mf">2.7302992</span><span class="p">,</span> <span class="mf">1.5029924</span><span class="p">,</span> <span class="mf">2.1892326</span><span class="p">,</span> <span class="mf">1.6283315</span><span class="p">,</span> <span class="mf">2.1436832</span><span class="p">,</span> <span class="mf">1.9183377</span><span class="p">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
 <span class="n">array</span><span class="p">([</span> <span class="mf">1.9165307</span> <span class="p">,</span>  <span class="mf">0.27995437</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.2910244</span> <span class="p">,</span> <span class="o">-</span><span class="mf">1.2921289</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.10231688</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">0.24934599</span><span class="p">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
<!-- ===================== Kết thúc dịch Phần 6 ===================== --><!-- ===================== Bắt đầu dịch Phần 7 ===================== --><!-- ========================================= REVISE PHẦN 3 - KẾT THÚC ===================================--><!-- ========================================= REVISE PHẦN 4 - BẮT ĐẦU ===================================--><!--
## Concise Implementation

--></div>
<div class="section" id="lap-trinh-suc-tich">
<h2><span class="section-number">7.5.5. </span>Lập trình súc tích<a class="headerlink" href="#lap-trinh-suc-tich" title="Permalink to this headline">¶</a></h2>
<!--
Compared with the `BatchNorm` class, which we just defined ourselves, the `BatchNorm` class defined by the `nn` model in Gluon is easier to use.
In Gluon, we do not have to worry about `num_features` or `num_dims`.
Instead, these parameter values will be inferred automatically via delayed initialization.
Otherwise, the code looks virtually identical to the application our implementation above.
--><p>So với lớp <code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code> tự định nghĩa thì lớp<code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code> định nghĩa
trong <code class="docutils literal notranslate"><span class="pre">nn</span></code> của Gluon dễ sử dụng hơn. Trong Gluon, ta không cần chỉ rõ
<code class="docutils literal notranslate"><span class="pre">num_features</span></code> và <code class="docutils literal notranslate"><span class="pre">num_dims</span></code>. Thay vào đó, các giá trị này sẽ được
tự động suy ra trong quá trình khởi tạo trễ. Ngoại trừ điểm đó, đoạn mã
trông giống hệt đoạn mã phía trên.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">net</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">()</span>
<span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm</span><span class="p">(),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm</span><span class="p">(),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm</span><span class="p">(),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">84</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm</span><span class="p">(),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<!--
Below, we use the same hyper-parameters to train out model.
Note that as usual, the Gluon variant runs much faster because its code has been compiled to C++/CUDA
while our custom implementation must be interpreted by Python.
--><p>Chúng ta sử dụng cùng các siêu tham số như trước để huấn luyện mô hình.
Như thường lệ, biến thể dùng Gluon này chạy nhanh hơn nhiều vì được biên
dịch thành C++/CUDA trong khi đoạn mã tùy chỉnh của chúng ta phải qua
thông dịch bằng Python.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d2l</span><span class="o">.</span><span class="n">train_ch6</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">train_iter</span><span class="p">,</span> <span class="n">test_iter</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">lr</span><span class="p">)</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">loss</span> <span class="mf">0.254</span><span class="p">,</span> <span class="n">train</span> <span class="n">acc</span> <span class="mf">0.906</span><span class="p">,</span> <span class="n">test</span> <span class="n">acc</span> <span class="mf">0.868</span>
<span class="mf">12456.2</span> <span class="n">examples</span><span class="o">/</span><span class="n">sec</span> <span class="n">on</span> <span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../_images/output_batch-norm_vn_e8f877_13_1.svg" src="../_images/output_batch-norm_vn_e8f877_13_1.svg" /></div>
<!--
## Controversy
--></div>
<div class="section" id="tranh-luan">
<h2><span class="section-number">7.5.6. </span>Tranh luận<a class="headerlink" href="#tranh-luan" title="Permalink to this headline">¶</a></h2>
<!--
Intuitively, batch normalization is thought to make the optimization landscape smoother.
However, we must be careful to distinguish between speculative intuitions and true explanations for the phenomena that we observe when training deep models.
Recall that we do not even know why simpler deep neural networks (MLPs and conventional CNNs) generalize well in the first place.
Even with dropout and L2 regularization, they remain so flexible that their ability to generalize to unseen data cannot be explained via conventional learning-theoretic generalization guarantees.
--><p>Theo trực giác, chuẩn hóa theo batch được cho là làm cảnh quan tối ưu
(<em>optimization landscape</em>) mượt mà hơn. Tuy nhiên, cần cẩn thận phân
biệt giữa suy đoán theo trực giác và lời giải thích thực sự cho các hiện
tượng quan sát thấy khi huấn luyện các mô hình học sâu. Hãy nhớ lại rằng
ngay từ đầu ta thậm chí không rõ tại sao các mạng nơ-ron sâu đơn giản
hơn (như Perceptron đa tầng và CNN truyền thống) lại có thể khái quát
tốt như vậy. Ngay cả với dropout và điều chuẩn L2, chúng vẫn linh hoạt
đến mức khả năng khái quát hóa trên dữ liệu chưa nhìn thấy của chúng
không thể giải thích được bằng các điều kiện bảo đảm sự khái quát hóa
trong lý thuyết học truyền thống.</p>
<!--
In the original paper proposing batch normalization, the authors, in addition to introducing a powerful and useful tool,
offered an explanation for why it works: by reducing *internal covariate shift*.
Presumably by *internal covariate shift* the authors meant something like the intuition expressed above—the notion that the distribution of activations changes over the course of training.
However there were two problems with this explanation:
(1) This drift is very different from *covariate shift*, rendering the name a misnomer.
(2) The explanation offers an under-specified intuition but leaves the question of *why precisely this technique works* an open question wanting for a rigorous explanation.
Throughout this book, we aim to convey the intuitions that practitioners use to guide their development of deep neural networks.
However, we believe that it is important to separate these guiding intuitions from established scientific fact.
Eventually, when you master this material and start writing your own research papers you will want to be clear to delineate between technical claims and hunches.
--><p>Trong bài báo gốc khi đề xuất phương pháp chuẩn hóa theo batch, các tác
giả ngoài việc giới thiệu một công cụ mạnh mẽ và hữu ích đã đưa ra lời
giải thích lý do BN hoạt động tốt: bằng cách giảm <em>sự dịch chuyển hiệp
biến nội bộ - internal covariate shift</em>. Có thể hiểu ý các tác giả về
<em>sự dịch chuyển hiệp biến nội bộ</em> giống với cách giải thích ở trên-rằng
phân phối của giá trị kích hoạt thay đổi trong quá trình huấn luyện. Tuy
nhiên, có hai vấn đề với cách giải thích này: (1) Sự dịch chuyển phân
phối này rất khác so với <em>sự dịch chuyển hiệp biến</em>, việc đặt tên như
vậy có sự nhầm lẫn. (2) Cách giải thích này vẫn chưa đủ cụ thể và chặt
chẽ, vẫn để ngỏ câu hỏi: <em>chính xác thì tại sao kỹ thuật này hoạt động?</em>
Xuyên suốt cuốn sách này, chúng tôi hướng đến việc truyền đạt những kinh
nghiệm thực tế để xây dựng các mạng nơ-ron sâu. Tuy nhiên, chúng tôi tin
rằng cần phân biệt rõ những kinh nghiệm dựa trên trực giác này với những
bằng chứng khoa học rõ ràng. Cuối cùng, khi đã thành thạo tài liệu này
và bắt đầu viết các nghiên cứu của riêng mình, bạn cần phân biệt rõ ràng
giữa khẳng định và linh cảm.</p>
<!--
Following the success of batch normalization, its explanation in terms of *internal covariate shift* has repeatedly surfaced
in debates in the technical literature and broader discourse about how to present machine learning research.
In a memorable speech given while accepting a Test of Time Award at the 2017 NeurIPS conference,
Ali Rahimi used *internal covariate shift* as a focal point in an argument likening the modern practice of deep learning to alchemy.
Subsequently, the example was revisited in detail in a position paper outlining troubling trends in machine learning :cite:`Lipton.Steinhardt.2018`.
In the technical literature other authors (:cite:`Santurkar.Tsipras.Ilyas.ea.2018`) have proposed alternative explanations for the success of BN,
some claiming that BN's success comes despite exhibiting behavior that is in some ways opposite to those claimed in the original paper.
--><p>Nối tiếp thành công của BN, cách giải thích của kỹ thuật này thông qua
khái niệm <em>sự dịch chuyển hiệp biến nội bộ</em> liên tục xuất hiện trong các
tranh luận, các tài liệu kỹ thuật và trên các diễn đàn về cách trình bày
nghiên cứu học máy. Trong một bài phát biểu đáng nhớ được đưa ra khi
nhận giải thưởng <strong>Test of Time Award</strong> tại hội nghị NeurIPS 2017, Ali
Rahimi đã sử dụng <em>sự dịch chuyển hiệp biến nội bộ</em> như một tiêu điểm
trong một cuộc tranh luận so sánh thực hành học sâu hiện đại với thuật
giả kim. Sau đó, cách giải thích này đã được xem xét lại một cách chi
tiết trong một bài báo về các xu hướng đáng lo ngại trong học máy
<a class="bibtex reference internal" href="../chapter_references/zreferences.html#lipton-steinhardt-2018" id="id4">[Lipton &amp; Steinhardt, 2018]</a>. Trong các tài liệu kỹ thuật, các tác
giả khác (<a class="bibtex reference internal" href="../chapter_references/zreferences.html#santurkar-tsipras-ilyas-ea-2018" id="id5">[Santurkar et al., 2018]</a>) đã đề xuất các giải
thích thay thế cho sự thành công của BN, dù phần nào đó trái ngược với
cách giải thích trong bài báo gốc.</p>
<!-- ===================== Kết thúc dịch Phần 7 ===================== --><!-- ===================== Bắt đầu dịch Phần 8 ===================== --><!--
We note that the *internal covariate shift* is no more worthy of criticism than any of thousands of similarly vague claims made every year in the technical ML literature.
Likely, its resonance as a focal point of these debates owes to its broad recognizability to the target audience.
Batch normalization has proven an indispensable method, applied in nearly all deployed image classifiers, earning the paper that introduced the technique tens of thousands of citations.
--><p>Chúng tôi lưu ý rằng <em>sự dịch chuyển hiệp biến nội bộ</em> không đáng bị chỉ
trích, có hàng ngàn lập luận mơ hồ được đưa ra mỗi năm trong nhiều tài
liệu kỹ thuật về học máy. Việc nó trở thành tâm điểm của những cuộc
tranh luận rất có thể là do sự phổ biến của nó trong cộng đồng học máy.
Chuẩn hóa theo batch là một phương pháp quan trọng, được áp dụng trong
gần như tất cả các bộ phân loại hình ảnh đã được triển khai, mang lại
hàng chục ngàn trích dẫn cho bài báo giới thiệu kĩ thuật này.</p>
<!--
## Summary
--></div>
<div class="section" id="tom-tat">
<h2><span class="section-number">7.5.7. </span>Tóm tắt<a class="headerlink" href="#tom-tat" title="Permalink to this headline">¶</a></h2>
<!--
* During model training, batch normalization continuously adjusts the intermediate output of the neural network by utilizing the mean and standard deviation of the minibatch, so that the values of the intermediate output in each layer throughout the neural network are more stable.
* The batch normalization methods for fully connected layers and convolutional layers are slightly different.
* Like a dropout layer, batch normalization layers have different computation results in training mode and prediction mode.
* Batch Normalization has many beneficial side effects, primarily that of regularization. On the other hand, the original motivation of reducing covariate shift seems not to be a valid explanation.
--><ul class="simple">
<li>Trong quá trình huấn luyện mô hình, chuẩn hóa theo batch liên tục
điều chỉnh đầu ra trung gian của mạng nơ-ron theo giá trị trung bình
và độ lệch chuẩn của minibatch, giúp các giá trị này ổn định hơn.</li>
<li>Chuẩn hóa theo batch có chút khác biệt khi áp dụng cho tầng kết nối
đầy đủ và tầng tích chập.</li>
<li>Giống như tầng dropout, tầng chuẩn hóa theo batch sẽ tính ra kết quả
khác nhau trong chế độ huấn luyện và chế độ dự đoán.</li>
<li>Chuẩn hóa theo batch có nhiều tác dụng phụ có lợi, chủ yếu là về điều
chuẩn. Tuy nhiên, cách giải thích ban đầu về việc giảm sự dịch chuyển
hiệp biến dường như không hợp lý.</li>
</ul>
<!--
## Exercises
--></div>
<div class="section" id="bai-tap">
<h2><span class="section-number">7.5.8. </span>Bài tập<a class="headerlink" href="#bai-tap" title="Permalink to this headline">¶</a></h2>
<!--
1. Can we remove the fully connected affine transformation before the batch normalization or the bias parameter in convolution computation?
    * Find an equivalent transformation that applies prior to the fully connected layer.
    * Is this reformulation effective. Why (not)?
2. Compare the learning rates for LeNet with and without batch normalization.
    * Plot the decrease in training and test error.
    * What about the region of convergence? How large can you make the learning rate?
3. Do we need Batch Normalization in every layer? Experiment with it?
4. Can you replace Dropout by Batch Normalization? How does the behavior change?
5. Fix the coefficients `beta` and `gamma` (add the parameter `grad_req='null'` at the time of construction to avoid calculating the gradient), and observe and analyze the results.
6. Review the Gluon documentation for `BatchNorm` to see the other applications for Batch Normalization.
7. Research ideas: think of other normalization transforms that you can apply? Can you apply the probability integral transform? How about a full rank covariance estimate?
--><ol class="arabic simple">
<li>Trước khi chuẩn hóa theo batch, có thể loại bỏ phép biến đổi affine
trong tầng kết nối đầy đủ hoặc tham số độ chệch trong phép tích chập
không?<ul>
<li>Tìm một phép biến đổi tương đương được áp dụng trước tầng kết nối
đầy đủ.</li>
<li>Sự cải tiến này có hiệu quả không, tại sao?</li>
</ul>
</li>
<li>So sánh tốc độ học của LeNet khi có sử dụng và không sử dụng chuẩn
hóa theo batch.<ul>
<li>Vẽ đồ thị biểu diễn sự giảm xuống của lỗi huấn luyện và lỗi kiểm
tra.</li>
<li>Về miền hội tụ thì sao? Có thể chọn tốc độ học lớn tới đâu?</li>
</ul>
</li>
<li>Chúng ta có cần chuẩn hóa theo batch trong tất cả các tầng không? Hãy
thử nghiệm điều này.</li>
<li>Có thể thay thế Dropout bằng BN không? Sẽ có thay đổi như thế nào?</li>
<li>Giữ nguyên các hệ số <code class="docutils literal notranslate"><span class="pre">beta</span></code> và <code class="docutils literal notranslate"><span class="pre">gamma</span></code> (thêm tham số
<code class="docutils literal notranslate"><span class="pre">grad_req='null'</span></code> khi xây dựng mạng để không tính gradient) rồi
quan sát và phân tích kết quả.</li>
<li>Đọc tài liệu của Gluon về <code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code> để xem các ứng dụng khác của
chuẩn hóa theo batch.</li>
<li>Ý tưởng nghiên cứu: nghĩ về các phép biến đổi chuẩn hóa khác có thể
áp dụng. Bạn có thể áp dụng biến đổi tích phân xác suất (<em>probability
integral transform</em>) không? Còn ước lượng ma trận hiệp phương sai
hạng tối đa thì sao?</li>
</ol>
<!-- ===================== Kết thúc dịch Phần 8 ===================== --><!-- ========================================= REVISE PHẦN 4 - KẾT THÚC ===================================--></div>
<div class="section" id="thao-luan">
<h2><span class="section-number">7.5.9. </span>Thảo luận<a class="headerlink" href="#thao-luan" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://discuss.mxnet.io/t/2358">Tiếng Anh</a></li>
<li><a class="reference external" href="https://forum.machinelearningcoban.com/c/d2l">Tiếng Việt</a></li>
</ul>
</div>
<div class="section" id="nhung-nguoi-thuc-hien">
<h2><span class="section-number">7.5.10. </span>Những người thực hiện<a class="headerlink" href="#nhung-nguoi-thuc-hien" title="Permalink to this headline">¶</a></h2>
<p>Bản dịch trong trang này được thực hiện bởi:</p>
<ul class="simple">
<li>Đoàn Võ Duy Thanh</li>
<li>Đinh Đắc</li>
<li>Lê Khắc Hồng Phúc</li>
<li>Nguyễn Văn Cường</li>
<li>Trần Yến Thy</li>
<li>Phạm Minh Đức</li>
<li>Nguyễn Cảnh Thướng</li>
<li>Phạm Hồng Vinh</li>
</ul>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">7.5. Chuẩn hoá theo batch</a><ul>
<li><a class="reference internal" href="#huan-luyen-mang-hoc-sau">7.5.1. Huấn luyện mạng học sâu</a></li>
<li><a class="reference internal" href="#tang-chuan-hoa-theo-batch">7.5.2. Tầng chuẩn hoá theo batch</a><ul>
<li><a class="reference internal" href="#tang-ket-noi-day-du">7.5.2.1. Tầng kết nối đầy đủ</a></li>
<li><a class="reference internal" href="#tang-tich-chap">7.5.2.2. Tầng tích chập</a></li>
<li><a class="reference internal" href="#chuan-hoa-theo-batch-trong-qua-trinh-du-doan">7.5.2.3. Chuẩn hoá theo Batch trong Quá trình Dự đoán</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lap-trinh-tu-dau">7.5.3. Lập trình từ đầu</a></li>
<li><a class="reference internal" href="#su-dung-lenet-voi-chuan-hoa-theo-batch">7.5.4. Sử dụng LeNet với Chuẩn hóa theo Batch</a></li>
<li><a class="reference internal" href="#lap-trinh-suc-tich">7.5.5. Lập trình súc tích</a></li>
<li><a class="reference internal" href="#tranh-luan">7.5.6. Tranh luận</a></li>
<li><a class="reference internal" href="#tom-tat">7.5.7. Tóm tắt</a></li>
<li><a class="reference internal" href="#bai-tap">7.5.8. Bài tập</a></li>
<li><a class="reference internal" href="#thao-luan">7.5.9. Thảo luận</a></li>
<li><a class="reference internal" href="#nhung-nguoi-thuc-hien">7.5.10. Những người thực hiện</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="googlenet_vn.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L fas fa-arrow-left fa-lg"></i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>7.4. Mạng nối song song (GoogLeNet)</div>
         </div>
     </a>
     <a id="button-next" href="resnet_vn.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
         <i class="pagenation-arrow-R fas fa-arrow-right fa-lg"></i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>7.6. Mạng phần dư (ResNet)</div>
        </div>
     </a>
  </div>
        
        </main>
    </div>
  </body>
</html>