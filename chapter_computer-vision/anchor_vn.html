<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>13.4. Khung neo &#8212; Đắm mình vào Học Sâu 0.14.4 documentation</title>

    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/d2l.css" />
    <link rel="stylesheet" href="../_static/material-design-lite-1.3.0/material.blue-deep_orange.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx_materialdesign_theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fontawesome/all.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/d2l.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="13.5. Phát hiện Vật thể Đa tỷ lệ" href="multiscale-object-detection_vn.html" />
    <link rel="prev" title="13.3. Phát hiện Vật thể và Khoanh vùng Đối tượng (Khung chứa)" href="bounding-box_vn.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link" href="index_vn.html"><span class="section-number">13. </span>Thị giác Máy tính</a><i class="material-icons">navigate_next</i>
            <a class="mdl-navigation__link is-active"><span class="section-number">13.4. </span>Khung neo</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../_sources/chapter_computer-vision/anchor_vn.rst.txt" rel="nofollow">
  <i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
          
              <a  class="mdl-navigation__link" href="https://github.com/aivivn/d2l-vn">
                  <i class="fab fa-github"></i>
                  GitHub
              </a>
          
              <a  class="mdl-navigation__link" href="https://forum.machinelearningcoban.com/">
                  <i class="fab fa-discourse"></i>
                  Forum
              </a>
          
              <a  class="mdl-navigation__link" href="https://www.d2l.ai/">
                  <i class="fas fa-external-link-alt"></i>
                  English
              </a>
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text-vi.png" alt="Đắm mình vào Học Sâu"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro_vn.html">Giới thiệu từ nhóm dịch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preface/index_vn.html">Lời nói đầu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_install/index_vn.html">Cài đặt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_notation/index_vn.html">Ký hiệu</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter_introduction/index_vn.html">1. Giới thiệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preliminaries/index_vn.html">2. Sơ bộ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/ndarray_vn.html">2.1. Thao tác với Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/pandas_vn.html">2.2. Tiền xử lý dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/linear-algebra_vn.html">2.3. Đại số tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/calculus_vn.html">2.4. Giải tích</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/autograd_vn.html">2.5. Tính vi phân Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/probability_vn.html">2.6. Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/lookup-api_vn.html">2.7. Tài liệu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_linear-networks/index_vn.html">3. Mạng nơ-ron Tuyến tính</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression_vn.html">3.1. Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-scratch_vn.html">3.2. Lập trình Hồi quy Tuyến tính từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-gluon_vn.html">3.3. Cách lập trình súc tích Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression_vn.html">3.4. Hồi quy Softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/fashion-mnist_vn.html">3.5. Bộ dữ liệu Phân loại Ảnh (Fashion-MNIST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-scratch_vn.html">3.6. Lập trình Hồi quy Sofmax từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-gluon_vn.html">3.7. Cách lập trình súc tích Hồi quy Softmax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_multilayer-perceptrons/index_vn.html">4. Perceptron Đa tầng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp_vn.html">4.1. Perceptron đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-scratch_vn.html">4.2. Lập trình Perceptron Đa tầng từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-gluon_vn.html">4.3. Cách lập trình súc tích Perceptron Đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/underfit-overfit_vn.html">4.4. Lựa Chọn Mô Hình, Dưới Khớp và Quá Khớp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/weight-decay_vn.html">4.5. Suy giảm trọng số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/dropout_vn.html">4.6. Dropout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/backprop_vn.html">4.7. Lan truyền xuôi, Lan truyền ngược và Đồ thị tính toán</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/numerical-stability-and-init_vn.html">4.8. Ổn định Số học và Khởi tạo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/environment_vn.html">4.9. Cân nhắc tới Môi trường</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/kaggle-house-price_vn.html">4.10. Dự đoán Giá Nhà trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_deep-learning-computation/index_vn.html">5. Tính toán Học sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/model-construction_vn.html">5.1. Tầng và Khối</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/parameters_vn.html">5.2. Quản lý Tham số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/deferred-init_vn.html">5.3. Khởi tạo trễ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/custom-layer_vn.html">5.4. Các tầng Tuỳ chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/read-write_vn.html">5.5. Đọc/Ghi tệp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/use-gpu_vn.html">5.6. GPU</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_convolutional-neural-networks/index_vn.html">6. Mạng Nơ-ron Tích chập</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/why-conv_vn.html">6.1. Từ Tầng Kết nối Dày đặc đến phép Tích chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/conv-layer_vn.html">6.2. Phép Tích chập cho Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/padding-and-strides_vn.html">6.3. Đệm và Sải Bước</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/channels_vn.html">6.4. Đa kênh Đầu vào và Đầu ra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/pooling_vn.html">6.5. Gộp (<em>Pooling</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/lenet_vn.html">6.6. Mạng Nơ-ron Tích chập (LeNet)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_convolutional-modern/index_vn.html">7. Mạng Nơ-ron Tích chập Hiện đại</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/alexnet_vn.html">7.1. Mạng Nơ-ron Tích chập Sâu (AlexNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/vgg_vn.html">7.2. Mạng sử dụng Khối (VGG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/nin_vn.html">7.3. Mạng trong Mạng (<em>Network in Network - NiN</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/googlenet_vn.html">7.4. Mạng nối song song (GoogLeNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/batch-norm_vn.html">7.5. Chuẩn hoá theo batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/resnet_vn.html">7.6. Mạng phần dư (ResNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/densenet_vn.html">7.7. Mạng Tích chập Kết nối Dày đặc (DenseNet)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-neural-networks/index_vn.html">8. Mạng Nơ-ron Hồi tiếp</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/sequence_vn.html">8.1. Mô hình chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/text-preprocessing_vn.html">8.2. Tiền Xử lý Dữ liệu Văn bản</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/language-models-and-dataset_vn.html">8.3. Mô hình Ngôn ngữ và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn_vn.html">8.4. Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-scratch_vn.html">8.5. Lập trình Mạng nơ-ron Hồi tiếp từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-gluon_vn.html">8.6. Lập trình súc tích Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/bptt_vn.html">8.7. Lan truyền Ngược qua Thời gian</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-modern/index_vn.html">9. Mạng Nơ-ron Hồi tiếp Hiện đại</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/gru_vn.html">9.1. Nút Hồi tiếp có Cổng (GRU)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/lstm_vn.html">9.2. Bộ nhớ Ngắn hạn Dài (LSTM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/deep-rnn_vn.html">9.3. Mạng Nơ-ron Hồi tiếp Sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/bi-rnn_vn.html">9.4. Mạng Nơ-ron Hồi tiếp Hai chiều</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/machine-translation-and-dataset_vn.html">9.5. Dịch Máy và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/encoder-decoder_vn.html">9.6. Kiến trúc Mã hoá - Giải mã</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/seq2seq_vn.html">9.7. Chuỗi sang Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/beam-search_vn.html">9.8. Tìm kiếm Chùm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_attention-mechanisms/index_vn.html">10. Cơ chế Tập trung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/attention_vn.html">10.1. Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/seq2seq-attention_vn.html">10.2. Chuỗi sang Chuỗi áp dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/transformer_vn.html">10.3. Kiến trúc Transformer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_optimization/index_vn.html">11. Thuật toán Tối ưu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html">11.1. Tối ưu và Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-thach-thuc-cua-toi-uu-trong-hoc-sau">11.2. Các Thách thức của Tối ưu trong Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-vung-cuc-tieu">11.3. Các vùng Cực tiểu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-diem-yen-ngua">11.4. Các điểm Yên ngựa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#tieu-bien-gradient">11.5. Tiêu biến Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/convexity_vn.html">11.6. Tính lồi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/gd_vn.html">11.7. Hạ Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/sgd_vn.html">11.8. Hạ Gradient Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/minibatch-sgd_vn.html">11.9. Hạ Gradient Ngẫu nhiên theo Minibatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/momentum_vn.html">11.10. Động lượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adagrad_vn.html">11.11. Adagrad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/rmsprop_vn.html">11.12. RMSProp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adadelta_vn.html">11.13. Adadelta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adam_vn.html">11.14. Adam</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/lr-scheduler_vn.html">11.15. Định thời Tốc độ Học</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_computational-performance/index_vn.html">12. Hiệu năng Tính toán</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hybridize_vn.html">12.1. Trình biên dịch và Trình thông dịch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/async-computation_vn.html">12.2. Tính toán Bất đồng bộ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/auto-parallelism_vn.html">12.3. Song song hóa Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hardware_vn.html">12.4. Phần cứng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus_vn.html">12.5. Huấn luyện đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus-concise_vn.html">12.6. Cách lập trình Súc tích đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/parameterserver_vn.html">12.7. Máy chủ Tham số</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index_vn.html">13. Thị giác Máy tính</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="image-augmentation_vn.html">13.1. Tăng cường Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="fine-tuning_vn.html">13.2. Tinh Chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="bounding-box_vn.html">13.3. Phát hiện Vật thể và Khoanh vùng Đối tượng (Khung chứa)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">13.4. Khung neo</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiscale-object-detection_vn.html">13.5. Phát hiện Vật thể Đa tỷ lệ</a></li>
<li class="toctree-l2"><a class="reference internal" href="object-detection-dataset_vn.html">13.6. Tập dữ liệu Phát hiện Đối tượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="ssd_vn.html">13.7. Phát hiện Nhiều khung Một lượt (SSD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="rcnn_vn.html">13.8. CNN theo Vùng (R-CNN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="semantic-segmentation-and-dataset_vn.html">13.9. Phân vùng theo Ngữ nghĩa và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="transposed-conv_vn.html">13.10. Tích chập Chuyển vị</a></li>
<li class="toctree-l2"><a class="reference internal" href="fcn_vn.html">13.11. Mạng Tích chập Đầy đủ</a></li>
<li class="toctree-l2"><a class="reference internal" href="neural-style_vn.html">13.12. Truyền tải Phong cách Nơ-ron</a></li>
<li class="toctree-l2"><a class="reference internal" href="kaggle-cifar10_vn.html">13.13. Phân loại ảnh (CIFAR-10) trên Kaggle</a></li>
<li class="toctree-l2"><a class="reference internal" href="kaggle-dog_vn.html">13.14. Nhận diện Giống Chó (ImageNet Dogs) trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/index_vn.html">14. Xử lý Ngôn ngữ Tự nhiên: Tiền Huấn luyện</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec_vn.html">14.1. Embedding Từ (word2vec)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/approx-training_vn.html">14.2. Huấn luyện Gần đúng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word-embedding-dataset_vn.html">14.3. Tập dữ liệu để Tiền Huấn luyện Embedding Từ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec-pretraining_vn.html">14.4. Tiền huấn luyện word2vec</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/glove_vn.html">14.5. Embedding từ với Vector Toàn cục (GloVe)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/subword-embedding_vn.html">14.6. Embedding từ con</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/similarity-analogy_vn.html">14.7. Tìm kiếm từ Đồng nghĩa và Loại suy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert_vn.html">14.8. Biểu diễn Mã hóa hai chiều từ Transformer (BERT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-dataset_vn.html">14.9. Tập dữ liệu để Tiền huấn luyện BERT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-pretraining_vn.html">14.10. Tiền Huấn luyện BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-applications/index_vn.html">15. Xử lý Ngôn ngữ Tự nhiên: Ứng dụng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-and-dataset_vn.html">15.1. Tác vụ Phân tích Cảm xúc và Bộ Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-rnn_vn.html">15.2. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-cnn_vn.html">15.3. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Tích Chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-and-dataset_vn.html">15.4. Suy luận ngôn ngữ tự nhiên và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-attention_vn.html">15.5. Suy luận Ngôn ngữ Tự nhiên: Sử dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/finetuning-bert_vn.html">15.6. Tinh chỉnh BERT cho các Ứng dụng Cấp Chuỗi và Cấp Token</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-bert_vn.html">15.7. Suy luận Ngôn ngữ Tự nhiên: Tinh chỉnh BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recommender-systems/index_vn.html">16. Hệ thống Đề xuất</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/recsys-intro_vn.html">16.1. Tổng quan về Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/movielens_vn.html">16.2. Tập dữ liệu MovieLens</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/mf_vn.html">16.3. Phân rã Ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/autorec_vn.html">16.4. AutoRec: Dự đoán Đánh giá với Bộ tự Mã hóa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ranking_vn.html">16.5. Cá nhân hóa Xếp hạng trong Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/neumf_vn.html">16.6. Lọc Cộng tác Nơ-ron cho Cá nhân hóa Xếp hạng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/seqrec_vn.html">16.7. Hệ thống Đề xuất có Nhận thức về Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ctr_vn.html">16.8. Hệ thống Đề xuất Giàu Đặc trưng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/fm_vn.html">16.9. Máy Phân rã ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/deepfm_vn.html">16.10. Máy Phân rã Ma trận Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_generative-adversarial-networks/index_vn.html">17. Mạng Đối sinh</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/gan_vn.html">17.1. Mạng Đối sinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/dcgan_vn.html">17.2. Mạng Đối sinh Tích chập Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/index_vn.html">18. Phụ lục: Toán học cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/geometry-linear-algebraic-ops_vn.html">18.1. Các phép toán Hình học và Đại số Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/eigendecomposition_vn.html">18.2. Phân rã trị riêng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/single-variable-calculus_vn.html">18.3. Giải tích một biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/multivariable-calculus_vn.html">18.4. Giải tích Nhiều biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/integral-calculus_vn.html">18.5. Giải tích Tích phân</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/random-variables_vn.html">18.6. Biến Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/maximum-likelihood_vn.html">18.7. Hợp lý Cực đại</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/distributions_vn.html">18.8. Các Phân phối Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/naive-bayes_vn.html">18.9. Bộ phân loại Naive Bayes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/statistics_vn.html">18.10. Thống kê</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/information-theory_vn.html">18.11. Lý thuyết Thông tin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/index_vn.html">19. Phụ lục: Công cụ cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/jupyter_vn.html">19.1. Sử dụng Jupyter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/sagemaker_vn.html">19.2. Sử dụng Amazon SageMaker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/aws_vn.html">19.3. Sử dụng Máy ảo AWS EC2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/colab_vn.html">19.4. Sử dụng Google Colab</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/selecting-servers-gpus_vn.html">19.5. Lựa chọn Máy chủ &amp; GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/contributing_vn.html">19.6. Đóng góp cho Quyển sách</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/d2l_vn.html">19.7. Tài liệu API của <code class="docutils literal notranslate"><span class="pre">d2l</span></code></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapter_references/zreferences.html">Tài liệu tham khảo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Bảng thuật ngữ</a></li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">

	<script type="text/javascript" src="../_static/sphinx_materialdesign_theme.js "></script>
    <header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text-vi.png" alt="Đắm mình vào Học Sâu"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro_vn.html">Giới thiệu từ nhóm dịch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preface/index_vn.html">Lời nói đầu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_install/index_vn.html">Cài đặt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_notation/index_vn.html">Ký hiệu</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter_introduction/index_vn.html">1. Giới thiệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_preliminaries/index_vn.html">2. Sơ bộ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/ndarray_vn.html">2.1. Thao tác với Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/pandas_vn.html">2.2. Tiền xử lý dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/linear-algebra_vn.html">2.3. Đại số tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/calculus_vn.html">2.4. Giải tích</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/autograd_vn.html">2.5. Tính vi phân Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/probability_vn.html">2.6. Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_preliminaries/lookup-api_vn.html">2.7. Tài liệu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_linear-networks/index_vn.html">3. Mạng nơ-ron Tuyến tính</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression_vn.html">3.1. Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-scratch_vn.html">3.2. Lập trình Hồi quy Tuyến tính từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/linear-regression-gluon_vn.html">3.3. Cách lập trình súc tích Hồi quy Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression_vn.html">3.4. Hồi quy Softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/fashion-mnist_vn.html">3.5. Bộ dữ liệu Phân loại Ảnh (Fashion-MNIST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-scratch_vn.html">3.6. Lập trình Hồi quy Sofmax từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_linear-networks/softmax-regression-gluon_vn.html">3.7. Cách lập trình súc tích Hồi quy Softmax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_multilayer-perceptrons/index_vn.html">4. Perceptron Đa tầng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp_vn.html">4.1. Perceptron đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-scratch_vn.html">4.2. Lập trình Perceptron Đa tầng từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/mlp-gluon_vn.html">4.3. Cách lập trình súc tích Perceptron Đa tầng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/underfit-overfit_vn.html">4.4. Lựa Chọn Mô Hình, Dưới Khớp và Quá Khớp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/weight-decay_vn.html">4.5. Suy giảm trọng số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/dropout_vn.html">4.6. Dropout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/backprop_vn.html">4.7. Lan truyền xuôi, Lan truyền ngược và Đồ thị tính toán</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/numerical-stability-and-init_vn.html">4.8. Ổn định Số học và Khởi tạo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/environment_vn.html">4.9. Cân nhắc tới Môi trường</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_multilayer-perceptrons/kaggle-house-price_vn.html">4.10. Dự đoán Giá Nhà trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_deep-learning-computation/index_vn.html">5. Tính toán Học sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/model-construction_vn.html">5.1. Tầng và Khối</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/parameters_vn.html">5.2. Quản lý Tham số</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/deferred-init_vn.html">5.3. Khởi tạo trễ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/custom-layer_vn.html">5.4. Các tầng Tuỳ chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/read-write_vn.html">5.5. Đọc/Ghi tệp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_deep-learning-computation/use-gpu_vn.html">5.6. GPU</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_convolutional-neural-networks/index_vn.html">6. Mạng Nơ-ron Tích chập</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/why-conv_vn.html">6.1. Từ Tầng Kết nối Dày đặc đến phép Tích chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/conv-layer_vn.html">6.2. Phép Tích chập cho Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/padding-and-strides_vn.html">6.3. Đệm và Sải Bước</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/channels_vn.html">6.4. Đa kênh Đầu vào và Đầu ra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/pooling_vn.html">6.5. Gộp (<em>Pooling</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-neural-networks/lenet_vn.html">6.6. Mạng Nơ-ron Tích chập (LeNet)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_convolutional-modern/index_vn.html">7. Mạng Nơ-ron Tích chập Hiện đại</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/alexnet_vn.html">7.1. Mạng Nơ-ron Tích chập Sâu (AlexNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/vgg_vn.html">7.2. Mạng sử dụng Khối (VGG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/nin_vn.html">7.3. Mạng trong Mạng (<em>Network in Network - NiN</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/googlenet_vn.html">7.4. Mạng nối song song (GoogLeNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/batch-norm_vn.html">7.5. Chuẩn hoá theo batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/resnet_vn.html">7.6. Mạng phần dư (ResNet)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_convolutional-modern/densenet_vn.html">7.7. Mạng Tích chập Kết nối Dày đặc (DenseNet)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-neural-networks/index_vn.html">8. Mạng Nơ-ron Hồi tiếp</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/sequence_vn.html">8.1. Mô hình chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/text-preprocessing_vn.html">8.2. Tiền Xử lý Dữ liệu Văn bản</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/language-models-and-dataset_vn.html">8.3. Mô hình Ngôn ngữ và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn_vn.html">8.4. Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-scratch_vn.html">8.5. Lập trình Mạng nơ-ron Hồi tiếp từ đầu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/rnn-gluon_vn.html">8.6. Lập trình súc tích Mạng nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-neural-networks/bptt_vn.html">8.7. Lan truyền Ngược qua Thời gian</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recurrent-modern/index_vn.html">9. Mạng Nơ-ron Hồi tiếp Hiện đại</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/gru_vn.html">9.1. Nút Hồi tiếp có Cổng (GRU)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/lstm_vn.html">9.2. Bộ nhớ Ngắn hạn Dài (LSTM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/deep-rnn_vn.html">9.3. Mạng Nơ-ron Hồi tiếp Sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/bi-rnn_vn.html">9.4. Mạng Nơ-ron Hồi tiếp Hai chiều</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/machine-translation-and-dataset_vn.html">9.5. Dịch Máy và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/encoder-decoder_vn.html">9.6. Kiến trúc Mã hoá - Giải mã</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/seq2seq_vn.html">9.7. Chuỗi sang Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recurrent-modern/beam-search_vn.html">9.8. Tìm kiếm Chùm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_attention-mechanisms/index_vn.html">10. Cơ chế Tập trung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/attention_vn.html">10.1. Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/seq2seq-attention_vn.html">10.2. Chuỗi sang Chuỗi áp dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_attention-mechanisms/transformer_vn.html">10.3. Kiến trúc Transformer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_optimization/index_vn.html">11. Thuật toán Tối ưu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html">11.1. Tối ưu và Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-thach-thuc-cua-toi-uu-trong-hoc-sau">11.2. Các Thách thức của Tối ưu trong Học sâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-vung-cuc-tieu">11.3. Các vùng Cực tiểu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#cac-diem-yen-ngua">11.4. Các điểm Yên ngựa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/optimization-intro_vn.html#tieu-bien-gradient">11.5. Tiêu biến Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/convexity_vn.html">11.6. Tính lồi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/gd_vn.html">11.7. Hạ Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/sgd_vn.html">11.8. Hạ Gradient Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/minibatch-sgd_vn.html">11.9. Hạ Gradient Ngẫu nhiên theo Minibatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/momentum_vn.html">11.10. Động lượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adagrad_vn.html">11.11. Adagrad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/rmsprop_vn.html">11.12. RMSProp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adadelta_vn.html">11.13. Adadelta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/adam_vn.html">11.14. Adam</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_optimization/lr-scheduler_vn.html">11.15. Định thời Tốc độ Học</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_computational-performance/index_vn.html">12. Hiệu năng Tính toán</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hybridize_vn.html">12.1. Trình biên dịch và Trình thông dịch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/async-computation_vn.html">12.2. Tính toán Bất đồng bộ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/auto-parallelism_vn.html">12.3. Song song hóa Tự động</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/hardware_vn.html">12.4. Phần cứng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus_vn.html">12.5. Huấn luyện đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/multiple-gpus-concise_vn.html">12.6. Cách lập trình Súc tích đa GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_computational-performance/parameterserver_vn.html">12.7. Máy chủ Tham số</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index_vn.html">13. Thị giác Máy tính</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="image-augmentation_vn.html">13.1. Tăng cường Ảnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="fine-tuning_vn.html">13.2. Tinh Chỉnh</a></li>
<li class="toctree-l2"><a class="reference internal" href="bounding-box_vn.html">13.3. Phát hiện Vật thể và Khoanh vùng Đối tượng (Khung chứa)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">13.4. Khung neo</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiscale-object-detection_vn.html">13.5. Phát hiện Vật thể Đa tỷ lệ</a></li>
<li class="toctree-l2"><a class="reference internal" href="object-detection-dataset_vn.html">13.6. Tập dữ liệu Phát hiện Đối tượng</a></li>
<li class="toctree-l2"><a class="reference internal" href="ssd_vn.html">13.7. Phát hiện Nhiều khung Một lượt (SSD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="rcnn_vn.html">13.8. CNN theo Vùng (R-CNN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="semantic-segmentation-and-dataset_vn.html">13.9. Phân vùng theo Ngữ nghĩa và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="transposed-conv_vn.html">13.10. Tích chập Chuyển vị</a></li>
<li class="toctree-l2"><a class="reference internal" href="fcn_vn.html">13.11. Mạng Tích chập Đầy đủ</a></li>
<li class="toctree-l2"><a class="reference internal" href="neural-style_vn.html">13.12. Truyền tải Phong cách Nơ-ron</a></li>
<li class="toctree-l2"><a class="reference internal" href="kaggle-cifar10_vn.html">13.13. Phân loại ảnh (CIFAR-10) trên Kaggle</a></li>
<li class="toctree-l2"><a class="reference internal" href="kaggle-dog_vn.html">13.14. Nhận diện Giống Chó (ImageNet Dogs) trên Kaggle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/index_vn.html">14. Xử lý Ngôn ngữ Tự nhiên: Tiền Huấn luyện</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec_vn.html">14.1. Embedding Từ (word2vec)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/approx-training_vn.html">14.2. Huấn luyện Gần đúng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word-embedding-dataset_vn.html">14.3. Tập dữ liệu để Tiền Huấn luyện Embedding Từ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/word2vec-pretraining_vn.html">14.4. Tiền huấn luyện word2vec</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/glove_vn.html">14.5. Embedding từ với Vector Toàn cục (GloVe)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/subword-embedding_vn.html">14.6. Embedding từ con</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/similarity-analogy_vn.html">14.7. Tìm kiếm từ Đồng nghĩa và Loại suy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert_vn.html">14.8. Biểu diễn Mã hóa hai chiều từ Transformer (BERT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-dataset_vn.html">14.9. Tập dữ liệu để Tiền huấn luyện BERT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-pretraining/bert-pretraining_vn.html">14.10. Tiền Huấn luyện BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_natural-language-processing-applications/index_vn.html">15. Xử lý Ngôn ngữ Tự nhiên: Ứng dụng</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-and-dataset_vn.html">15.1. Tác vụ Phân tích Cảm xúc và Bộ Dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-rnn_vn.html">15.2. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Hồi tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/sentiment-analysis-cnn_vn.html">15.3. Phân tích Cảm xúc: Sử dụng Mạng Nơ-ron Tích Chập</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-and-dataset_vn.html">15.4. Suy luận ngôn ngữ tự nhiên và Tập dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-attention_vn.html">15.5. Suy luận Ngôn ngữ Tự nhiên: Sử dụng Cơ chế Tập trung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/finetuning-bert_vn.html">15.6. Tinh chỉnh BERT cho các Ứng dụng Cấp Chuỗi và Cấp Token</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_natural-language-processing-applications/natural-language-inference-bert_vn.html">15.7. Suy luận Ngôn ngữ Tự nhiên: Tinh chỉnh BERT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_recommender-systems/index_vn.html">16. Hệ thống Đề xuất</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/recsys-intro_vn.html">16.1. Tổng quan về Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/movielens_vn.html">16.2. Tập dữ liệu MovieLens</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/mf_vn.html">16.3. Phân rã Ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/autorec_vn.html">16.4. AutoRec: Dự đoán Đánh giá với Bộ tự Mã hóa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ranking_vn.html">16.5. Cá nhân hóa Xếp hạng trong Hệ thống Đề xuất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/neumf_vn.html">16.6. Lọc Cộng tác Nơ-ron cho Cá nhân hóa Xếp hạng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/seqrec_vn.html">16.7. Hệ thống Đề xuất có Nhận thức về Chuỗi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/ctr_vn.html">16.8. Hệ thống Đề xuất Giàu Đặc trưng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/fm_vn.html">16.9. Máy Phân rã ma trận</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_recommender-systems/deepfm_vn.html">16.10. Máy Phân rã Ma trận Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_generative-adversarial-networks/index_vn.html">17. Mạng Đối sinh</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/gan_vn.html">17.1. Mạng Đối sinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_generative-adversarial-networks/dcgan_vn.html">17.2. Mạng Đối sinh Tích chập Sâu</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/index_vn.html">18. Phụ lục: Toán học cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/geometry-linear-algebraic-ops_vn.html">18.1. Các phép toán Hình học và Đại số Tuyến tính</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/eigendecomposition_vn.html">18.2. Phân rã trị riêng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/single-variable-calculus_vn.html">18.3. Giải tích một biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/multivariable-calculus_vn.html">18.4. Giải tích Nhiều biến</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/integral-calculus_vn.html">18.5. Giải tích Tích phân</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/random-variables_vn.html">18.6. Biến Ngẫu nhiên</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/maximum-likelihood_vn.html">18.7. Hợp lý Cực đại</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/distributions_vn.html">18.8. Các Phân phối Xác suất</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/naive-bayes_vn.html">18.9. Bộ phân loại Naive Bayes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/statistics_vn.html">18.10. Thống kê</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-mathematics-for-deep-learning/information-theory_vn.html">18.11. Lý thuyết Thông tin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/index_vn.html">19. Phụ lục: Công cụ cho Học Sâu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/jupyter_vn.html">19.1. Sử dụng Jupyter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/sagemaker_vn.html">19.2. Sử dụng Amazon SageMaker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/aws_vn.html">19.3. Sử dụng Máy ảo AWS EC2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/colab_vn.html">19.4. Sử dụng Google Colab</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/selecting-servers-gpus_vn.html">19.5. Lựa chọn Máy chủ &amp; GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/contributing_vn.html">19.6. Đóng góp cho Quyển sách</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_appendix-tools-for-deep-learning/d2l_vn.html">19.7. Tài liệu API của <code class="docutils literal notranslate"><span class="pre">d2l</span></code></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapter_references/zreferences.html">Tài liệu tham khảo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Bảng thuật ngữ</a></li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content" role="main">
        
  <!--
# Anchor Boxes
--><div class="section" id="khung-neo">
<span id="sec-anchor"></span><h1><span class="section-number">13.4. </span>Khung neo<a class="headerlink" href="#khung-neo" title="Permalink to this headline">¶</a></h1>
<!--
Object detection algorithms usually sample a large number of regions in the input image, determine whether these regions contain objects of interest,
and adjust the edges of the regions so as to predict the ground-truth bounding box of the target more accurately.
Different models may use different region sampling methods.
Here, we introduce one such method: it generates multiple bounding boxes with different sizes and aspect ratios while centering on each pixel.
These bounding boxes are called anchor boxes.
We will practice object detection based on anchor boxes in the following sections.
--><p>Các giải thuật phát hiện vật thể thường lấy mẫu ở rất nhiều vùng của ảnh
đầu vào, rồi xác định xem các vùng đó có chứa đối tượng cần quan tâm hay
không, và điều chỉnh biên của vùng lấy mẫu này để dự đoán khung chứa
nhãn gốc của đối tượng một cách chính xác hơn. Các mô hình khác nhau có
thể dùng các phương pháp lấy mẫu vùng ảnh khác nhau. Ở đây, chúng tôi sẽ
giới thiệu một phương pháp đó là: tạo ra nhiều khung chứa với kích thước
và tỷ lệ cạnh khác nhau với tâm trên từng điểm ảnh. Các khung chứa đó
được gọi là các khung neo. Chúng ta sẽ thực hành phát hiện vật thể dựa
trên các khung neo ở các phần sau.</p>
<!--
First, import the packages or modules required for this section.
Here, we have modified the printing accuracy of NumPy.
Because printing tensors actually calls the print function of NumPy, the floating-point numbers in tensors printed in this section are more concise.
--><p>Trước tiên, hãy nhập các gói và mô-đun cần thiết cho mục này. Tại đây,
ta đã chỉnh sửa độ chính xác khi in số thực của Numpy. Vì ta đang gọi
hàm in của Numpy khi in các tensor, nên các tensor số thực dấu phẩy động
sẽ được in ra dưới dạng súc tích hơn.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="kn">from</span> <span class="nn">d2l</span> <span class="kn">import</span> <span class="n">mxnet</span> <span class="k">as</span> <span class="n">d2l</span>
<span class="kn">from</span> <span class="nn">mxnet</span> <span class="kn">import</span> <span class="n">gluon</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">npx</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">npx</span><span class="o">.</span><span class="n">set_np</span><span class="p">()</span>
</pre></div>
</div>
<!--
## Generating Multiple Anchor Boxes
--><div class="section" id="sinh-nhieu-khung-neo">
<h2><span class="section-number">13.4.1. </span>Sinh nhiều Khung neo<a class="headerlink" href="#sinh-nhieu-khung-neo" title="Permalink to this headline">¶</a></h2>
<!--
Assume that the input image has a height of $h$ and width of $w$.
We generate anchor boxes with different shapes centered on each pixel of the image.
Assume the size is $s\in (0, 1]$, the aspect ratio is $r > 0$, and the width and height of the anchor box are $ws\sqrt{r}$ and $hs/\sqrt{r}$, respectively.
When the center position is given, an anchor box with known width and height is determined.
--><p>Giả sử ảnh đầu vào có chiều cao <span class="math notranslate nohighlight">\(h\)</span> và chiều rộng <span class="math notranslate nohighlight">\(w\)</span>. Ta
sinh ra các khung neo với kích thước khác nhau có tâm tại mỗi điểm ảnh.
Giả sử kích thước này <span class="math notranslate nohighlight">\(s\in (0, 1]\)</span>, tỷ lệ cạnh là <span class="math notranslate nohighlight">\(r &gt;0\)</span>,
chiều rộng và chiều cao của khung neo lần lượt là <span class="math notranslate nohighlight">\(ws\sqrt{r}\)</span> và
<span class="math notranslate nohighlight">\(hs/\sqrt{r}\)</span>. Với một vị trí tâm cho trước, ta xác định được
khung neo với chiều cao và chiều rộng như trên.</p>
<!--
Below we set a set of sizes $s_1,\ldots, s_n$ and a set of aspect ratios $r_1,\ldots, r_m$.
If we use a combination of all sizes and aspect ratios with each pixel as the center, the input image will have a total of $whnm$ anchor boxes.
Although these anchor boxes may cover all ground-truth bounding boxes, the computational complexity is often excessive.
Therefore, we are usually only interested in a combination containing $s_1$ or $r_1$ sizes and aspect ratios, that is:
--><p>Dưới đây, ta thiết lập một tập kích thước <span class="math notranslate nohighlight">\(s_1,\ldots, s_n\)</span> và một
tập tỷ lệ khung <span class="math notranslate nohighlight">\(r_1,\ldots, r_m\)</span>. Nếu ta dùng tổ hợp tất cả các
kích thước và tỷ lệ khung với mỗi điểm ảnh làm một tâm, ảnh đầu vào sẽ
có tổng cộng <span class="math notranslate nohighlight">\(whnm\)</span> khung neo. Mặc dù các khung chứa chuẩn đối
tượng có thể sẽ nằm trong số đó, nhưng độ phức tạp tính toán này thường
quá cao. Do đó, ta thường chỉ chú ý tới tổ hợp chứa <span class="math notranslate nohighlight">\(s_1\)</span> kích
thước hoặc <span class="math notranslate nohighlight">\(r_1\)</span> tỷ lệ khung như sau:</p>
<div class="math notranslate nohighlight" id="equation-chapter-computer-vision-anchor-vn-0">
<span class="eqno">(13.4.1)<a class="headerlink" href="#equation-chapter-computer-vision-anchor-vn-0" title="Permalink to this equation">¶</a></span>\[(s_1, r_1), (s_1, r_2), \ldots, (s_1, r_m), (s_2, r_1), (s_3, r_1), \ldots, (s_n, r_1).\]</div>
<!--
That is, the number of anchor boxes centered on the same pixel is $n+m-1$.
For the entire input image, we will generate a total of $wh(n+m-1)$ anchor boxes.
--><p>Ở trên, số khung neo có tâm trên cùng một điểm ảnh là <span class="math notranslate nohighlight">\(n+m-1\)</span>. Đối
với toàn bộ bức ảnh đầu vào, ta sẽ sinh ra tổng cộng <span class="math notranslate nohighlight">\(wh(n+m-1)\)</span>
khung neo.</p>
<!--
The above method of generating anchor boxes has been implemented in the `multibox_prior` function.
We specify the input, a set of sizes, and a set of aspect ratios, and this function will return all the anchor boxes entered.
--><p>Phương pháp sinh khung neo ở trên được lập trình sẵn trong hàm
<code class="docutils literal notranslate"><span class="pre">multibox_prior</span></code>. Ta chỉ cần thiết lập đầu vào, tập các kích thước và
tập các tỉ số cạnh, rồi hàm này sẽ trả về tất cả các khung neo như mong
muốn.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;../img/catdog.jpg&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>  <span class="c1"># Construct input data</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">npx</span><span class="o">.</span><span class="n">multibox_prior</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="p">[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span> <span class="n">ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">Y</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">561</span> <span class="mi">728</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2042040</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<!--
We can see that the shape of the returned anchor box variable `y` is (batch size, number of anchor boxes, 4).
After changing the shape of the anchor box variable `y` to (image height, image width, number of anchor boxes centered on the same pixel, 4),
we can obtain all the anchor boxes centered on a specified pixel position.
In the following example, we access the first anchor box centered on (250, 250).
It has four elements: the $x, y$ axis coordinates in the upper-left corner and the $x, y$ axis coordinates in the lower-right corner of the anchor box.
The coordinate values of the $x$ and $y$ axis are divided by the width and height of the image, respectively, so the value range is between 0 and 1.
--><p>Ta có thể thấy rằng kích thước của khung neo được trả về ở biến <code class="docutils literal notranslate"><span class="pre">y</span></code> là
(kích thước batch, số khung neo, 4). Sau khi thay đổi kích thước của
<code class="docutils literal notranslate"><span class="pre">y</span></code> thành (chiều cao ảnh, chiều rộng ảnh, số khung neo có tâm trên
cùng một điểm ảnh, 4), ta sẽ thu được tất cả các khung neo với tâm ở một
vị trí điểm ảnh nhất định. Trong phần ví dụ dưới đây, ta truy xuất khung
neo đầu tiên có tâm tại vị trí (250, 250). Nó có bốn phần tử: tọa độ
trục <span class="math notranslate nohighlight">\(x, y\)</span> ở góc trên bên trái và tọa độ trục <span class="math notranslate nohighlight">\(x, y\)</span> ở góc
dưới bên phải của khung neo. Tọa độ của các trục <span class="math notranslate nohighlight">\(x\)</span> và <span class="math notranslate nohighlight">\(y\)</span>
được chia lần lượt cho chiều rộng và độ cao của ảnh, do đó giá trị của
chúng sẽ nằm trong khoảng 0 và 1.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">boxes</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">boxes</span><span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([</span><span class="mf">0.06</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.63</span><span class="p">,</span> <span class="mf">0.82</span><span class="p">])</span>
</pre></div>
</div>
<!--
In order to describe all anchor boxes centered on one pixel in the image, we first define the `show_bboxes` function to draw multiple bounding boxes on the image.
--><p>Để mô tả tất cả các khung neo có tâm trên cùng một điểm của bức ảnh,
trước hết ta sẽ định nghĩa hàm <code class="docutils literal notranslate"><span class="pre">show_bboxes</span></code> để vẽ nhóm khung chứa
trên ảnh này.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#@save</span>
<span class="k">def</span> <span class="nf">show_bboxes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Show bounding boxes.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_make_list</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">default_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">default_values</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">_make_list</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">_make_list</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)]</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">d2l</span><span class="o">.</span><span class="n">bbox_to_rect</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">color</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">text_color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span> <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rect</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                      <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">text_color</span><span class="p">,</span>
                      <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<!--
As we just saw, the coordinate values of the $x$ and $y$ axis in the variable `boxes` have been divided by the width and height of the image, respectively.
When drawing images, we need to restore the original coordinate values of the anchor boxes and therefore define the variable `bbox_scale`.
Now, we can draw all the anchor boxes centered on (250, 250) in the image.
As you can see, the blue anchor box with a size of 0.75 and an aspect ratio of 1 covers the dog in the image well.
--><p>Như chúng ta vừa thấy, các giá trị tọa độ của trục <span class="math notranslate nohighlight">\(x\)</span> và
<span class="math notranslate nohighlight">\(y\)</span> trong biến <code class="docutils literal notranslate"><span class="pre">boxes</span></code> đã được chia lần lượt cho chiều rộng và
chiều cao của ảnh. Khi vẽ ảnh, ta cần khôi phục các giá trị tọa độ gốc
của các khung neo và xác định biến <code class="docutils literal notranslate"><span class="pre">bbox_scale</span></code>. Lúc này, ta có thể vẽ
tất cả các khung neo có tâm tại vị trí (250, 250) của bức ảnh này. Như
bạn có thể thấy, khung neo màu xanh dương với kích thước 0.75 và tỉ số
cạnh 1 sẽ bao quanh khá tốt chú chó trong hình này.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d2l</span><span class="o">.</span><span class="n">set_figsize</span><span class="p">()</span>
<span class="n">bbox_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">d2l</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="n">show_bboxes</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">boxes</span><span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">bbox_scale</span><span class="p">,</span>
            <span class="p">[</span><span class="s1">&#39;s=0.75, r=1&#39;</span><span class="p">,</span> <span class="s1">&#39;s=0.5, r=1&#39;</span><span class="p">,</span> <span class="s1">&#39;s=0.25, r=1&#39;</span><span class="p">,</span> <span class="s1">&#39;s=0.75, r=2&#39;</span><span class="p">,</span>
             <span class="s1">&#39;s=0.75, r=0.5&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../_images/output_anchor_vn_f30d52_9_0.svg" src="../_images/output_anchor_vn_f30d52_9_0.svg" /></div>
<!--
## Intersection over Union
--></div>
<div class="section" id="giao-tren-hop">
<h2><span class="section-number">13.4.2. </span>Giao trên Hợp<a class="headerlink" href="#giao-tren-hop" title="Permalink to this headline">¶</a></h2>
<!--
We just mentioned that the anchor box covers the dog in the image well.
If the ground-truth bounding box of the target is known, how can "well" here be quantified? An intuitive method is to measure the similarity between anchor boxes and the ground-truth bounding box.
We know that the Jaccard index can measure the similarity between two sets.
Given sets $\mathcal{A}$ and $\mathcal{B}$, their Jaccard index is the size of their intersection divided by the size of their union:
--><p>Chúng ta chỉ mới đề cập rằng khung neo đó bao quanh tốt chú chó trong
ảnh. Nếu ta biết khung chứa nhãn gốc của đối tượng, làm thế nào để định
lượng được “mức độ tốt” ở đây? Một phương pháp đơn giản là đo điểm tương
đồng giữa các khung neo và khung chứa nhãn gốc. Và ta biết rằng hệ số
Jaccard có thể đo lường sự tương đồng giữa hai tập dữ liệu. Với hai tập
hợp <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> và <span class="math notranslate nohighlight">\(\mathcal{B}\)</span>, chỉ số Jaccard của chúng
là kích thước của phần giao trên kích thước của phần hợp:</p>
<div class="math notranslate nohighlight" id="equation-chapter-computer-vision-anchor-vn-1">
<span class="eqno">(13.4.2)<a class="headerlink" href="#equation-chapter-computer-vision-anchor-vn-1" title="Permalink to this equation">¶</a></span>\[J(\mathcal{A},\mathcal{B}) = \frac{\left|\mathcal{A} \cap \mathcal{B}\right|}{\left| \mathcal{A} \cup \mathcal{B}\right|}.\]</div>
<!--
In fact, we can consider the pixel area of a bounding box as a collection of pixels.
In this way, we can measure the similarity of the two bounding boxes by the Jaccard index of their pixel sets.
When we measure the similarity of two bounding boxes, we usually refer the Jaccard index as intersection over union (IoU),
which is the ratio of the intersecting area to the union area of the two bounding boxes, as shown in :numref:`fig_iou`.
The value range of IoU is between 0 and 1: 0 means that there are no overlapping pixels between the two bounding boxes, while 1 indicates that the two bounding boxes are equal.
--><p>Trong thực tế, chúng ta có thể coi vùng điểm ảnh trong khung chứa là một
tập hợp các điểm ảnh. Theo cách này, ta có thể đo lường được tính tương
đồng của hai khung chứa bằng hệ số Jaccard của các tập điểm ảnh tương
ứng. Khi đo sự tương đồng giữa hai khung chứa, hệ số Jaccard thường được
gọi là Giao trên Hợp (<em>Intersection over Union - IoU</em>), tức tỷ lệ giữa
vùng giao nhau và vùng kết hợp của hai khung chứa ảnh, được thể hiện
trong <a class="reference internal" href="#fig-iou"><span class="std std-numref">Fig. 13.4.1</span></a>. Miền giá trị của IoU nằm trong khoảng từ 0
đến 1: giá trị 0 có nghĩa là không có điểm ảnh nào giao nhau giữa hai
khung chứa, trong khi đó giá trị 1 chỉ ra rằng hai khung chứa ấy hoàn
toàn trùng nhau.</p>
<!--
![IoU is the ratio of the intersecting area to the union area of two bounding boxes.](../img/iou.svg)
--><div class="figure align-default" id="id1">
<span id="fig-iou"></span><img alt="../_images/iou.svg" src="../_images/iou.svg" /><p class="caption"><span class="caption-number">Fig. 13.4.1 </span><span class="caption-text">IoU là tỷ lệ giữa vùng giao trên vùng hợp của hai khung chứa.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<!--
For the remainder of this section, we will use IoU to measure the similarity between anchor boxes and ground-truth bounding boxes, and between different anchor boxes.
--><p>Trong phần còn lại, chúng ta sẽ dùng IoU để đo sự tương đồng giữa các
khung neo với khung chứa nhãn gốc và giữa các khung neo với nhau.</p>
<!--
## Labeling Training Set Anchor Boxes
--></div>
<div class="section" id="gan-nhan-khung-neo-trong-tap-huan-luyen">
<h2><span class="section-number">13.4.3. </span>Gán nhãn Khung neo trong tập Huấn luyện<a class="headerlink" href="#gan-nhan-khung-neo-trong-tap-huan-luyen" title="Permalink to this headline">¶</a></h2>
<!--
In the training set, we consider each anchor box as a training example.
In order to train the object detection model, we need to mark two types of labels for each anchor box: first, the category of the target contained in the anchor box (category) and,
second, the offset of the ground-truth bounding box relative to the anchor box (offset).
In object detection, we first generate multiple anchor boxes, predict the categories and offsets for each anchor box,
adjust the anchor box position according to the predicted offset to obtain the bounding boxes to be used for prediction,
and finally filter out the prediction bounding boxes that need to be output.
--><p>Trong tập huấn luyện, chúng ta xem mỗi khung neo là một mẫu huấn luyện.
Để huấn luyện mô hình phát hiện đối tượng, chúng ta cần đánh dấu hai
loại nhãn cho mỗi khung neo: thứ nhất là hạng mục (<em>category</em>) của đối
tượng trong khung neo, thứ hai là độ dời tương đối (<em>offset</em>) của khung
chứa nhãn gốc so với khung neo. Trong việc phát hiện đối tượng, trước
tiên ta tạo ra nhiều khung neo, dự đoán các hạng mục và độ dời cho từng
khung neo, hiệu chỉnh vị trí của chúng dựa theo độ lệch dự kiến để có
được những khung chứa và sau cùng là lọc ra các khung chứa mà cần được
dự đoán.</p>
<!--
We know that, in the object detection training set, each image is labelled with the location of the ground-truth bounding box and the category of the target contained.
After the anchor boxes are generated, we primarily label anchor boxes based on the location and category information of the ground-truth bounding boxes similar to the anchor boxes.
So how do we assign ground-truth bounding boxes to anchor boxes similar to them?
--><p>Chúng ta biết rằng, trong tập huấn luyện phát hiện đối tượng, mỗi hình
ảnh được gán nhãn với vị trí của khung chứa nhãn gốc và hạng mục của đối
tượng. Ta gán nhãn cho các khung neo sau khi tạo chủ yếu dựa vào thông
tin vị trí và hạng mục của các khung chứa nhãn gốc tương đồng với các
khung neo đó. Vậy làm thế nào để gán các khung chứa nhãn gốc cho những
khung neo tương đồng với chúng?</p>
<!--
Assume that the anchor boxes in the image are $A_1, A_2, \ldots, A_{n_a}$ and the ground-truth bounding boxes are $B_1, B_2, \ldots, B_{n_b}$ and $n_a \geq n_b$.
Define matrix $\mathbf{X} \in \mathbb{R}^{n_a \times n_b}$, where element $x_{ij}$ in the $i^\mathrm{th}$ row and $j^\mathrm{th}$ column is
the IoU of the anchor box $A_i$ to the ground-truth bounding box $B_j$.
First, we find the largest element in the matrix $\mathbf{X}$ and record the row index and column index of the element as $i_1,j_1$.
We assign the ground-truth bounding box $B_{j_1}$ to the anchor box $A_{i_1}$.
Obviously, anchor box $A_{i_1}$ and ground-truth bounding box $B_{j_1}$ have the highest similarity among all the "anchor box--ground-truth bounding box" pairings.
Next, discard all elements in the $i_1$th row and the $j_1$th column in the matrix $\mathbf{X}$.
Find the largest remaining element in the matrix $\mathbf{X}$ and record the row index and column index of the element as $i_2,j_2$.
We assign ground-truth bounding box $B_{j_2}$ to anchor box $A_{i_2}$ and then discard all elements in the $i_2$th row and the $j_2$th column in the matrix $\mathbf{X}$.
At this point, elements in two rows and two columns in the matrix $\mathbf{X}$ have been discarded.
--><p>Giả sử rằng các khung neo trên ảnh là <span class="math notranslate nohighlight">\(A_1, A_2, \ldots, A_{n_a}\)</span>
và các khung chứa nhãn gốc là <span class="math notranslate nohighlight">\(B_1, B_2, \ldots, B_{n_b}\)</span> và
<span class="math notranslate nohighlight">\(n_a \geq n_b\)</span>. Xây dựng ma trận
<span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{n_a \times n_b}\)</span>, trong đó mỗi phần tử
<span class="math notranslate nohighlight">\(x_{ij}\)</span> trong hàng <span class="math notranslate nohighlight">\(i^\mathrm{th}\)</span> và cột
<span class="math notranslate nohighlight">\(j^\mathrm{th}\)</span> là hệ số IoU của khung neo <span class="math notranslate nohighlight">\(A_i\)</span> so với
khung chứa nhãn gốc <span class="math notranslate nohighlight">\(B_j\)</span>. Đầu tiên, ta tìm ra phần tử lớn nhất
trong ma trận <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> rồi lưu lại chỉ mục hàng và cột của
phần tử đó là <span class="math notranslate nohighlight">\(i_1,j_1\)</span>, rồi gán khung chứa nhãn gốc
<span class="math notranslate nohighlight">\(B_{j_1}\)</span> cho khung neo <span class="math notranslate nohighlight">\(A_{i_1}\)</span>. Rõ ràng, khung neo
<span class="math notranslate nohighlight">\(A_{i_1}\)</span> và khung chứa nhãn gốc <span class="math notranslate nohighlight">\(B_{j_1}\)</span> có độ tương đồng
cao nhất trong số tất cả các cặp “khung neo–khung chứa nhãn gốc”. Tiếp
theo, loại bỏ các phần tử trong hàng <span class="math notranslate nohighlight">\(i_1\)</span> và cột <span class="math notranslate nohighlight">\(j_1\)</span>
trong ma trận <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>. Tìm phần tử lớn nhất trong các phần tử
còn lại trong ma trận <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> rồi cũng lưu lại chỉ mục hàng
và cột của phần tử đó là <span class="math notranslate nohighlight">\(i_2,j_2\)</span>. Chúng ta gán khung chứa nhãn
gốc <span class="math notranslate nohighlight">\(B_{j_2}\)</span> cho khung neo <span class="math notranslate nohighlight">\(A_{i_2}\)</span> và sau đó loại bỏ mọi
phần tử tại hàng <span class="math notranslate nohighlight">\(i_2\)</span> và cột <span class="math notranslate nohighlight">\(j_2\)</span> trong ma trận
<span class="math notranslate nohighlight">\(\mathbf{X}\)</span>. Như vậy, tại thời điểm này thì các phần tử trong hai
hàng và hai cột của ma trận <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> đã bị loại bỏ.</p>
<!--
We proceed until all elements in the $n_b$ column in the matrix $\mathbf{X}$ are discarded.
At this time, we have assigned a ground-truth bounding box to each of the $n_b$ anchor boxes.
Next, we only traverse the remaining $n_a - n_b$ anchor boxes.
Given anchor box $A_i$, find the bounding box $B_j$ with the largest IoU with $A_i$ according to the $i^\mathrm{th}$ row of the matrix $\mathbf{X}$,
and only assign ground-truth bounding box $B_j$ to anchor box $A_i$ when the IoU is greater than the predetermined threshold.
--><p>Ta tiến hành việc này cho đến khi các phần tử ở cột <span class="math notranslate nohighlight">\(n_b\)</span> trong ma
trận <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> đều bị loại bỏ. Tại thời điểm này, chúng ta đều
đã gán <span class="math notranslate nohighlight">\(n_b\)</span> khung chứa nhãn gốc cho <span class="math notranslate nohighlight">\(n_b\)</span> khung neo. Tiếp
đến, chỉ việc duyệt qua <span class="math notranslate nohighlight">\(n_a - n_b\)</span> khung neo còn lại. Với khung
neo <span class="math notranslate nohighlight">\(A_i\)</span>, ta cần tìm ra khung chứa nhãn gốc <span class="math notranslate nohighlight">\(B_j\)</span> sao cho
khung chứa ấy có hệ số IoU so với <span class="math notranslate nohighlight">\(A_i\)</span> là lớn nhất trên hàng
<span class="math notranslate nohighlight">\(i\)</span> của ma trận <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>, và chỉ gán khung chứa nhãn gốc
<span class="math notranslate nohighlight">\(B_j\)</span> cho khung neo <span class="math notranslate nohighlight">\(A_i\)</span> khi mà hệ số IoU lớn hơn một
ngưỡng cho trước.</p>
<!--
As shown in :numref:`fig_anchor_label` (left), assuming that the maximum value in the matrix $\mathbf{X}$ is $x_{23}$, we will assign ground-truth bounding box $B_3$ to anchor box $A_2$.
Then, we discard all the elements in row 2 and column 3 of the matrix, find the largest element $x_{71}$ of the remaining shaded area, and assign ground-truth bounding box $B_1$ to anchor box $A_7$.
Then, as shown in :numref:`fig_anchor_label` (middle), discard all the elements in row 7 and column 1 of the matrix,
find the largest element $x_{54}$ of the remaining shaded area, and assign ground-truth bounding box $B_4$ to anchor box $A_5$.
Finally, as shown in :numref:`fig_anchor_label` (right), discard all the elements in row 5 and column 4 of the matrix,
find the largest element $x_{92}$ of the remaining shaded area, and assign ground-truth bounding box $B_2$ to anchor box $A_9$.
After that, we only need to traverse the remaining anchor boxes of $A_1, A_3, A_4, A_6, A_8$
and determine whether to assign ground-truth bounding boxes to the remaining anchor boxes according to the threshold.
--><p>Như mô tả ở <a class="reference internal" href="#fig-anchor-label"><span class="std std-numref">Fig. 13.4.2</span></a> (trái), giả sử giá trị lớn nhất
của ma trận <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> là <span class="math notranslate nohighlight">\(x_{23}\)</span>, ta gán khung chứa nhãn
gốc <span class="math notranslate nohighlight">\(B_3\)</span> cho khung neo <span class="math notranslate nohighlight">\(A_2\)</span>. Tiếp theo ta loại bỏ tất cả
các giá trị ở hàng 2 và cột 3 của ma trận, tìm phần tử lớn nhất
<span class="math notranslate nohighlight">\(x_{71}\)</span> của phần ma trận còn lại và gán khung chứa nhãn gốc
<span class="math notranslate nohighlight">\(B_1\)</span> cho khung neo <span class="math notranslate nohighlight">\(A_7\)</span>. Sau đó, như trong
<a class="reference internal" href="#fig-anchor-label"><span class="std std-numref">Fig. 13.4.2</span></a> (giữa), ta loại bỏ tất cả các giá trị ở
hàng 7 và cột 1 của ma trận, tìm phần tử lớn nhất <span class="math notranslate nohighlight">\(x_{54}\)</span> của
phần ma trận còn lại và gán khung chứa nhãn gốc <span class="math notranslate nohighlight">\(B_4\)</span> cho khung
neo <span class="math notranslate nohighlight">\(A_5\)</span>. Cuối cùng, trong :numref:<code class="docutils literal notranslate"><span class="pre">fig_anchor_label</span></code> (phải),
ta loại bỏ tất cả các giá trị ở hàng 5 và cột 4 của ma trận, tìm phần tử
lớn nhất <span class="math notranslate nohighlight">\(x_{92}\)</span> của phần ma trận còn lại và gán khung chứa nhãn
gốc <span class="math notranslate nohighlight">\(B_2\)</span> cho khung neo <span class="math notranslate nohighlight">\(A_9\)</span>. Sau đó ta chỉ cần duyệt các
khung neo còn lại <span class="math notranslate nohighlight">\(A_1, A_3, A_4, A_6, A_8\)</span> và dựa vào mức ngưỡng
để quyết định có gán khung chứa nhãn gốc cho các khung neo này không.</p>
<!--
![Assign ground-truth bounding boxes to anchor boxes.](../img/anchor-label.svg)
--><div class="figure align-default" id="id2">
<span id="fig-anchor-label"></span><img alt="../_images/anchor-label.svg" src="../_images/anchor-label.svg" /><p class="caption"><span class="caption-number">Fig. 13.4.2 </span><span class="caption-text">Gán khung chứa nhãn gốc cho các khung neo.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<!--
Now we can label the categories and offsets of the anchor boxes.
If an anchor box $A$ is assigned ground-truth bounding box $B$, the category of the anchor box $A$ is set to the category of $B$.
And the offset of the anchor box $A$ is set according to the relative position of the central coordinates of $B$ and $A$ and the relative sizes of the two boxes.
Because the positions and sizes of various boxes in the dataset may vary,
these relative positions and relative sizes usually require some special transformations to make the offset distribution more uniform and easier to fit.
Assume the center coordinates of anchor box $A$ and its assigned ground-truth bounding box $B$ are $(x_a, y_a), (x_b, y_b)$,
the widths of $A$ and $B$ are $w_a, w_b$, and their heights are $h_a, h_b$, respectively.
In this case, a common technique is to label the offset of $A$ as
--><p>Giờ ta có thể gán nhãn hạng mục và độ dời cho các khung neo. Nếu khung
neo <span class="math notranslate nohighlight">\(A\)</span> được gán khung chứa nhãn gốc <span class="math notranslate nohighlight">\(B\)</span> thì khung neo
<span class="math notranslate nohighlight">\(A\)</span> sẽ có cùng hạng mục với <span class="math notranslate nohighlight">\(B\)</span>. Độ dời của khung neo
<span class="math notranslate nohighlight">\(A\)</span> được đặt dựa theo vị trí tương đối của tọa độ tâm của
<span class="math notranslate nohighlight">\(B\)</span> và <span class="math notranslate nohighlight">\(A\)</span> cũng như kích thước tương đối của hai khung. Do
vị trí và kích thước của các khung trong tập dữ liệu thường khá đa dạng,
các vị trí và kích thước tương đối này thường yêu cầu một số phép biến
đổi đặc biệt sao cho phân phối của giá trị độ dời trở nên đều và dễ khớp
hơn. Giả sử tọa độ tâm của khung neo <span class="math notranslate nohighlight">\(A\)</span> và khung chứa nhãn gốc
<span class="math notranslate nohighlight">\(B\)</span> được gán cho nó là <span class="math notranslate nohighlight">\((x_a, y_a), (x_b, y_b)\)</span>, chiều rộng
của <span class="math notranslate nohighlight">\(A\)</span> và <span class="math notranslate nohighlight">\(B\)</span> lần lượt là <span class="math notranslate nohighlight">\(w_a, w_b\)</span>, và chiều cao
lần lượt là <span class="math notranslate nohighlight">\(h_a, h_b\)</span>. Đối với trường hợp này, một kỹ thuật phổ
biến là gán nhãn độ dời của <span class="math notranslate nohighlight">\(A\)</span> như sau</p>
<div class="math notranslate nohighlight" id="equation-chapter-computer-vision-anchor-vn-2">
<span class="eqno">(13.4.3)<a class="headerlink" href="#equation-chapter-computer-vision-anchor-vn-2" title="Permalink to this equation">¶</a></span>\[\left( \frac{ \frac{x_b - x_a}{w_a} - \mu_x }{\sigma_x},
\frac{ \frac{y_b - y_a}{h_a} - \mu_y }{\sigma_y},
\frac{ \log \frac{w_b}{w_a} - \mu_w }{\sigma_w},
\frac{ \log \frac{h_b}{h_a} - \mu_h }{\sigma_h}\right),\]</div>
<!--
The default values of the constant are $\mu_x = \mu_y = \mu_w = \mu_h = 0, \sigma_x=\sigma_y=0.1, and \sigma_w=\sigma_h=0.2$.
If an anchor box is not assigned a ground-truth bounding box, we only need to set the category of the anchor box to background.
Anchor boxes whose category is background are often referred to as negative anchor boxes, and the rest are referred to as positive anchor boxes.
--><p>Giá trị mặc định của các hằng số là
<span class="math notranslate nohighlight">\(\mu_x = \mu_y = \mu_w = \mu_h = 0, \sigma_x=\sigma_y=0.1, và \sigma_w=\sigma_h=0.2\)</span>.
Nếu một khung neo không được gán cho một khung chứa nhãn gốc, ta chỉ cần
gán hạng mục của khung neo này là nền. Các khung neo có hạng mục là nền
thường được gọi là khung neo âm, và tất cả các khung neo còn lại được
gọi là khung neo dương.</p>
<!--
Below we demonstrate a detailed example.
We define ground-truth bounding boxes for the cat and dog in the read image, where the first element is category (0 for dog, 1 for cat)
and the remaining four elements are the $x, y$ axis coordinates at top-left corner and $x, y$ axis coordinates at lower-right corner (the value range is between 0 and 1).
Here, we construct five anchor boxes to be labeled by the coordinates of the upper-left corner and the lower-right corner,
which are recorded as $A_0, \ldots, A_4$, respectively (the index in the program starts from 0).
First, draw the positions of these anchor boxes and the ground-truth bounding boxes in the image.
--><p>Dưới đây chúng tôi sẽ giải thích chi tiết một ví dụ. Ta định nghĩa các
khung chứa nhãn gốc cho con mèo và con chó trong ảnh đã đọc, trong đó
phần tử đầu tiên là hạng mục (0 là chó, 1 là mèo) và bốn phần tử còn lại
là các tọa độ <span class="math notranslate nohighlight">\(x, y\)</span> của góc trên bên trái và tọa độ <span class="math notranslate nohighlight">\(x, y\)</span>
của góc dưới bên phải (dải giá trị nằm trong khoảng từ 0 đến 1). Ở đây
ta khởi tạo năm khung neo bằng tọa độ của góc trên bên trái và góc dưới
bên phải để gán nhãn, được kí hiệu lần lượt là <span class="math notranslate nohighlight">\(A_0, \ldots, A_4\)</span>
(chỉ số trong chương trình bắt đầu từ 0). Đầu tiên, ta vẽ vị trí của các
khung neo này và các khung chứa nhãn gốc vào ảnh.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ground_truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.52</span><span class="p">,</span> <span class="mf">0.92</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.88</span><span class="p">]])</span>
<span class="n">anchors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.63</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.88</span><span class="p">,</span> <span class="mf">0.98</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.66</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.57</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.92</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">d2l</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="n">show_bboxes</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">ground_truth</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">bbox_scale</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">],</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">show_bboxes</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">anchors</span> <span class="o">*</span> <span class="n">bbox_scale</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">]);</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../_images/output_anchor_vn_f30d52_11_0.svg" src="../_images/output_anchor_vn_f30d52_11_0.svg" /></div>
<!--
We can label categories and offsets for anchor boxes by using the `multibox_target` function.
This function sets the background category to 0 and increments the integer index of the target category from zero by 1 (1 for dog and 2 for cat).
We add example dimensions to the anchor boxes and ground-truth bounding boxes and construct random predicted results
with a shape of (batch size, number of categories including background, number of anchor boxes) by using the `expand_dims` function.
--><p>Ta có thể gán hạng mục và độ dời cho các khung neo này bằng cách sử dụng
hàm <code class="docutils literal notranslate"><span class="pre">multibox_target</span></code>. Hàm này đặt hạng mục nền bằng 0 và tăng chỉ số
lên 1 với mỗi hạng mục mục tiêu (1 là chó và 2 là mèo). Ta thêm chiều
mẫu vào các tensor chứa khung neo và khung chứa nhãn gốc ở ví dụ trên và
khởi tạo kết quả dự đoán ngẫu nhiên với kích thước (kích thước batch, số
hạng mục tính cả nền, số khung neo) bằng cách sử dụng hàm
<code class="docutils literal notranslate"><span class="pre">expand_dims</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span> <span class="o">=</span> <span class="n">npx</span><span class="o">.</span><span class="n">multibox_target</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ground_truth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
</pre></div>
</div>
<!--
There are three items in the returned result, all of which are in the tensor format.
The third item is represented by the category labeled for the anchor box.
--><p>Có ba phần tử trong kết quả trả về, tất cả đều theo định dạng tensor.
Phần tử thứ ba là hạng mục được gán nhãn cho khung neo.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
</pre></div>
</div>
<!--
We analyze these labelled categories based on positions of anchor boxes and ground-truth bounding boxes in the image.
First, in all "anchor box--ground-truth bounding box" pairs, the IoU of anchor box $A_4$ to the ground-truth bounding box of the cat is the largest,so the category of anchor box $A_4$ is labeled as cat.
Without considering anchor box $A_4$ or the ground-truth bounding box of the cat, in the remaining "anchor box--ground-truth bounding box" pairs,
the pair with the largest IoU is anchor box $A_1$ and the ground-truth bounding box of the dog, so the category of anchor box $A_1$ is labeled as dog.
Next, traverse the remaining three unlabeled anchor boxes.
he category of the ground-truth bounding box with the largest IoU with anchor box $A_0$ is dog, but the IoU is smaller than the threshold (the default is 0.5), so the category is labeled as background;
the category of the ground-truth bounding box with the largest IoU with anchor box $A_2$ is cat and the IoU is greater than the threshold, so the category is labeled as cat;
the category of the ground-truth bounding box with the largest IoU with anchor box $A_3$ is cat, but the IoU is smaller than the threshold, so the category is labeled as background.
--><p>Ta phân tích các hạng mục được gán nhãn này dựa theo vị trí của khung
neo và khung chứa nhãn gốc trong ảnh. Đầu tiên, trong tất cả các cặp
“khung neo—khung chứa nhãn gốc”, giá trị IoU của khung neo <span class="math notranslate nohighlight">\(A_4\)</span>
đối với khung chứa nhãn gốc mèo là lớn nhất, vậy hạng mục của khung neo
<span class="math notranslate nohighlight">\(A_4\)</span> được gán là mèo. Nếu ta không xét khung neo <span class="math notranslate nohighlight">\(A_4\)</span> hoặc
khung chứa nhãn gốc mèo, trong các cặp “khung neo—khung chứa nhãn gốc”
còn lại, cặp với giá trị IoU lớn nhất là khung neo <span class="math notranslate nohighlight">\(A_1\)</span> và khung
chứa nhãn gốc chó, vậy hạng mục của khung neo <span class="math notranslate nohighlight">\(A_1\)</span> được gán là
chó. Tiếp theo ta xét ba khung neo còn lại chưa được gán nhãn. Hạng mục
của khung chứa nhãn gốc có giá trị IoU lớn nhất với khung neo
<span class="math notranslate nohighlight">\(A_0\)</span> là chó, tuy nhiên giá trị IoU này lại nhỏ hơn mức ngưỡng
(mặc định là 0.5), do đó khung neo này được gán nhãn là nền; hạng mục
của khung chứa nhãn gốc có giá trị IoU lớn nhất với khung neo
<span class="math notranslate nohighlight">\(A_2\)</span> là mèo và giá trị IoU này lớn hơn mức ngưỡng, do đó khung
neo này được gán nhãn là mèo; hạng mục của khung chứa nhãn gốc có giá
trị IoU lớn nhất với khung neo <span class="math notranslate nohighlight">\(A_3\)</span> là mèo, tuy nhiên giá trị IoU
này lại nhỏ hơn mức ngưỡng, do đó khung neo này được gán nhãn là nền.</p>
<!--
The second item of the return value is a mask variable, with the shape of (batch size, four times the number of anchor boxes).
The elements in the mask variable correspond one-to-one with the four offset values of each anchor box.
Because we do not care about background detection, offsets of the negative class should not affect the target function.
By multiplying by element, the 0 in the mask variable can filter out negative class offsets before calculating target function.
--><p>Phần tử thứ hai trong giá trị trả về là một biến mặt nạ (<em>mask
variable</em>), với kích thước (kích thước batch, số khung neo nhân bốn).
Các phần tử trong biến mặt nạ tương ứng một - một với bốn giá trị độ dời
của mỗi khung neo. Do ta không cần quan tâm đến việc nhận diện nền nên
độ dời thuộc lớp âm không ảnh hướng đến hàm mục tiêu. Qua phép nhân theo
từng phần tử, các giá trị 0 trong biến mặt nạ có thể lọc ra các độ dời
thuộc lớp âm trước khi tính hàm mục tiêu.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span>
        <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
</pre></div>
</div>
<!--
The first item returned is the four offset values labeled for each anchor box, with the offsets of negative class anchor boxes labeled as 0.
--><p>Phần tử đầu tiên trong giá trị trả về là bốn giá trị độ dời được gán
nhãn cho mỗi khung neo, với giá trị độ dời của các khung neo thuộc lớp
âm được gán nhãn là 0.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[</span> <span class="mf">0.00e+00</span><span class="p">,</span>  <span class="mf">0.00e+00</span><span class="p">,</span>  <span class="mf">0.00e+00</span><span class="p">,</span>  <span class="mf">0.00e+00</span><span class="p">,</span>  <span class="mf">1.40e+00</span><span class="p">,</span>  <span class="mf">1.00e+01</span><span class="p">,</span>
         <span class="mf">2.59e+00</span><span class="p">,</span>  <span class="mf">7.18e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.20e+00</span><span class="p">,</span>  <span class="mf">2.69e-01</span><span class="p">,</span>  <span class="mf">1.68e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.57e+00</span><span class="p">,</span>
         <span class="mf">0.00e+00</span><span class="p">,</span>  <span class="mf">0.00e+00</span><span class="p">,</span>  <span class="mf">0.00e+00</span><span class="p">,</span>  <span class="mf">0.00e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.71e-01</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.00e+00</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">8.94e-07</span><span class="p">,</span>  <span class="mf">6.26e-01</span><span class="p">]])</span>
</pre></div>
</div>
<!--
## Bounding Boxes for Prediction
--></div>
<div class="section" id="khung-chua-khi-du-doan">
<h2><span class="section-number">13.4.4. </span>Khung chứa khi Dự đoán<a class="headerlink" href="#khung-chua-khi-du-doan" title="Permalink to this headline">¶</a></h2>
<!--
During model prediction phase, we first generate multiple anchor boxes for the image and then predict categories and offsets for these anchor boxes one by one.
Then, we obtain prediction bounding boxes based on anchor boxes and their predicted offsets.
When there are many anchor boxes, many similar prediction bounding boxes may be output for the same target.
To simplify the results, we can remove similar prediction bounding boxes.
A commonly used method is called non-maximum suppression (NMS).
--><p>Trong giai đoạn dự đoán, đầu tiên ta tạo ra nhiều khung neo cho bức ảnh,
sau đó dự đoán hạng mục và độ dời của từng khung neo. Tiếp theo, ta thu
được những khung chứa dự đoán dựa trên các khung neo và độ dời dự đoán
của chúng. Khi tồn tại nhiều khung neo, nhiều khung chứa dự đoán tương
tự nhau có thể được tạo ra cho cùng một mục tiêu. Để đơn giản hóa kết
quả, ta có thể loại bỏ những khung chứa dự đoán giống nhau. Một phương
pháp thường được sử dụng là triệt phi cực đại (<em>non-maximum suppression
- NMS</em>).</p>
<!--
Let us take a look at how NMS works.
For a prediction bounding box $B$, the model calculates the predicted probability for each category.
Assume the largest predicted probability is $p$, the category corresponding to this probability is the predicted category of $B$.
We also refer to $p$ as the confidence level of prediction bounding box $B$.
On the same image, we sort the prediction bounding boxes with predicted categories other than background by confidence level from high to low, and obtain the list $L$.
Select the prediction bounding box $B_1$ with highest confidence level from $L$ as a baseline and remove all non-benchmark prediction bounding boxes
with an IoU with $B_1$ greater than a certain threshold from $L$.
The threshold here is a preset hyperparameter.
At this point, $L$ retains the prediction bounding box with the highest confidence level and removes other prediction bounding boxes similar to it.
--><p>Hãy cùng xem cách NMS hoạt động. Đối với khung chứa dự đoán <span class="math notranslate nohighlight">\(B\)</span>,
mô hình sẽ dự đoán xác suất cho từng hạng mục. Giả sử rằng xác suất dự
đoán lớn nhất là <span class="math notranslate nohighlight">\(p\)</span>, hạng mục tương ứng với xác suất này sẽ là
hạng mục dự đoán của <span class="math notranslate nohighlight">\(B\)</span>. Ta gọi <span class="math notranslate nohighlight">\(p\)</span> là độ tin cậy
(<em>confidence level</em>) của khung chứa dự đoán <span class="math notranslate nohighlight">\(B\)</span>. Trên cùng một bức
ảnh, ta sắp xếp các khung chứa dự đoán không phải là nền theo thứ tự
giảm dần độ tin cậy, thu được danh sách <span class="math notranslate nohighlight">\(L\)</span>. Ta chọn ra khung chứa
dự đoán có mức tin cậy cao nhất <span class="math notranslate nohighlight">\(B_1\)</span> từ <span class="math notranslate nohighlight">\(L\)</span> để làm chuẩn so
sánh và loại bỏ tất cả khung chứa dự đoán “không chuẩn” có hệ số IoU với
khung chứa <span class="math notranslate nohighlight">\(B_1\)</span> lớn hơn một ngưỡng nhất định khỏi danh sách
<span class="math notranslate nohighlight">\(L\)</span>. Mức ngưỡng này là một siêu tham số được định trước. Tại thời
điểm này, <span class="math notranslate nohighlight">\(L\)</span> chỉ còn khung chứa dự đoán có độ tin cậy cao nhất
sau khi đã loại bỏ những khung chứa giống nó.</p>
<!--
Next, select the prediction bounding box $B_2$ with the second highest confidence level from $L$ as a baseline,
and remove all non-benchmark prediction bounding boxes with an IoU with $B_2$ greater than a certain threshold from $L$.
Repeat this process until all prediction bounding boxes in $L$ have been used as a baseline.
At this time, the IoU of any pair of prediction bounding boxes in $L$ is less than the threshold.
Finally, output all prediction bounding boxes in the list $L$.
--><p>Sau đó, ta chọn tiếp khung chứa dự đoán <span class="math notranslate nohighlight">\(B_2\)</span> có độ tin cậy cao
thứ hai trong <span class="math notranslate nohighlight">\(L\)</span> để làm chuẩn so sánh, và loại bỏ tất cả khung
chứa dự đoán “không chuẩn” khác có hệ số IoU so với khung chứa
<span class="math notranslate nohighlight">\(B_2\)</span> lớn hơn một ngưỡng nhất định khỏi <span class="math notranslate nohighlight">\(L\)</span>. Ta sẽ lặp lại
quy trình này cho đến khi tất cả khung chứa dự đoán trong <span class="math notranslate nohighlight">\(L\)</span> đã
được sử dụng làm chuẩn so sánh. Lúc này, IoU của bất cứ cặp khung chứa
dự đoán nào trong <span class="math notranslate nohighlight">\(L\)</span> đều nhỏ hơn ngưỡng cho trước. Cuối cùng, đầu
ra sẽ là mọi khung chứa dự đoán còn lại trong <span class="math notranslate nohighlight">\(L\)</span>.</p>
<!--
Next, we will look at a detailed example.
First, construct four anchor boxes.
For the sake of simplicity, we assume that predicted offsets are all 0.
This means that the prediction bounding boxes are anchor boxes.
Finally, we construct a predicted probability for each category.
--><p>Tiếp theo, hãy xem xét một ví dụ chi tiết. Trước tiên, ta tạo bốn khung
neo. Để đơn giản hóa vấn đề, ta giả định rằng độ dời dự đoán đều bằng 0,
nghĩa là các khung chứa dự đoán đều là các khung neo. Cuối cùng, ta định
ra một xác suất dự đoán cho từng lớp.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">anchors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.52</span><span class="p">,</span> <span class="mf">0.92</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.56</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.62</span><span class="p">,</span> <span class="mf">0.91</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.55</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.88</span><span class="p">]])</span>
<span class="n">offset_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">anchors</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">cls_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>  <span class="c1"># Predicted probability for background</span>
                      <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>  <span class="c1"># Predicted probability for dog</span>
                      <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>  <span class="c1"># Predicted probability for cat</span>
</pre></div>
</div>
<!--
Print prediction bounding boxes and their confidence levels on the image.
--><p>In các khung chứa dự đoán cùng với độ tin cậy trên ảnh</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">d2l</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="n">show_bboxes</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">anchors</span> <span class="o">*</span> <span class="n">bbox_scale</span><span class="p">,</span>
            <span class="p">[</span><span class="s1">&#39;dog=0.9&#39;</span><span class="p">,</span> <span class="s1">&#39;dog=0.8&#39;</span><span class="p">,</span> <span class="s1">&#39;dog=0.7&#39;</span><span class="p">,</span> <span class="s1">&#39;cat=0.9&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../_images/output_anchor_vn_f30d52_23_0.svg" src="../_images/output_anchor_vn_f30d52_23_0.svg" /></div>
<!--
We use the `multibox_detection` function to perform NMS and set the threshold to 0.5.
This adds an example dimension to the tensor input.
We can see that the shape of the returned result is (batch size, number of anchor boxes, 6).
The 6 elements of each row represent the output information for the same prediction bounding box.
The first element is the predicted category index, which starts from 0 (0 is dog, 1 is cat).
The value -1 indicates background or removal in NMS.
The second element is the confidence level of prediction bounding box.
The remaining four elements are the $x, y$ axis coordinates of the upper-left corner and the $x, y$ axis coordinates of the lower-right corner
of the prediction bounding box (the value range is between 0 and 1).
--><p>Ta dùng hàm <code class="docutils literal notranslate"><span class="pre">multibox_detection</span></code> để thực hiện triệt phi cực đại và đặt
ngưỡng là 0.5. Hàm này tạo thêm chiều mẫu trong tensor đầu vào. Ta có
thể thấy kích thước của kết quả trả về là (kích thước batch, số lượng
khung neo, 6). 6 phần tử của từng hàng biểu diễn thông tin đầu ra của
một khung chứa dự đoán. Phần tử đầu tiên là chỉ số của hạng mục dự đoán,
bắt đầu từ 0 (0 là chó, 1 là mèo). Giá trị -1 cho biết đó là nền hoặc
khung bị loại bỏ bởi triệt phi cực đại. Phần tử thứ hai chính là độ tin
cậy của khung chứa dự đoán. Bốn phần tử còn lại là các tọa độ
<span class="math notranslate nohighlight">\(x, y\)</span> của góc trên bên trái và góc dưới bên phải của khung chứa
dự đoán (miền giá trị nằm trong khoảng từ 0 đến 1).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="n">npx</span><span class="o">.</span><span class="n">multibox_detection</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">cls_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">offset_preds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">nms_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">output</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[[</span> <span class="mf">0.</span>  <span class="p">,</span>  <span class="mf">0.9</span> <span class="p">,</span>  <span class="mf">0.1</span> <span class="p">,</span>  <span class="mf">0.08</span><span class="p">,</span>  <span class="mf">0.52</span><span class="p">,</span>  <span class="mf">0.92</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">0.9</span> <span class="p">,</span>  <span class="mf">0.55</span><span class="p">,</span>  <span class="mf">0.2</span> <span class="p">,</span>  <span class="mf">0.9</span> <span class="p">,</span>  <span class="mf">0.88</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">0.8</span> <span class="p">,</span>  <span class="mf">0.08</span><span class="p">,</span>  <span class="mf">0.2</span> <span class="p">,</span>  <span class="mf">0.56</span><span class="p">,</span>  <span class="mf">0.95</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">0.7</span> <span class="p">,</span>  <span class="mf">0.15</span><span class="p">,</span>  <span class="mf">0.3</span> <span class="p">,</span>  <span class="mf">0.62</span><span class="p">,</span>  <span class="mf">0.91</span><span class="p">]]])</span>
</pre></div>
</div>
<!--
We remove the prediction bounding boxes of category -1 and visualize the results retained by NMS.
--><p>Ta loại bỏ các khung chứa dự đoán có giá trị -1 rồi trực quan hóa các
kết quả còn được giữ lại sau khi triệt phi cực đại.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">d2l</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dog=&#39;</span><span class="p">,</span> <span class="s1">&#39;cat=&#39;</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">show_bboxes</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="o">*</span> <span class="n">bbox_scale</span><span class="p">],</span> <span class="n">label</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../_images/output_anchor_vn_f30d52_27_0.svg" src="../_images/output_anchor_vn_f30d52_27_0.svg" /></div>
<!--
In practice, we can remove prediction bounding boxes with lower confidence levels before performing NMS, thereby reducing the amount of computation for NMS.
We can also filter the output of NMS, for example, by only retaining results with higher confidence levels as the final output.
--><p>Trong thực tế, ta có thể loại bỏ các khung chứa dự đoán có mức độ tin
cậy thấp trước khi thực hiện triệt phi cực đại để giảm bớt chi phí tính
toán. Ta cũng có thể lọc các đầu ra sau khi triệt phi cực đại, ví dụ,
bằng cách chỉ giữ lại những kết quả có độ tin cậy cao để làm đầu ra cuối
cùng.</p>
</div>
<div class="section" id="tom-tat">
<h2><span class="section-number">13.4.5. </span>Tóm tắt<a class="headerlink" href="#tom-tat" title="Permalink to this headline">¶</a></h2>
<!--
* We generate multiple anchor boxes with different sizes and aspect ratios, centered on each pixel.
* IoU, also called Jaccard index, measures the similarity of two bounding boxes. It is the ratio of the intersecting area to the union area of two bounding boxes.
* In the training set, we mark two types of labels for each anchor box:
one is the category of the target contained in the anchor box and the other is the offset of the ground-truth bounding box relative to the anchor box.
* When predicting, we can use non-maximum suppression (NMS) to remove similar prediction bounding boxes, thereby simplifying the results.
--><ul class="simple">
<li>Chúng ta tạo ra nhiều khung neo với nhiều kích thước và tỷ lệ khác
nhau, bao quanh từng điểm ảnh.</li>
<li>IoU, còn được gọi là hệ số Jaccard, đo lường độ tương đồng giữa hai
khung chứa. Đó là tỷ lệ của phần giao trên phần hợp của hai khung
chứa.</li>
<li>Trong tập huấn luyện, ta đánh dấu hai loại nhãn cho mỗi khung neo:
hạng mục của đối tượng trong khung neo và độ dời của khung chứa chuẩn
so với khung neo.</li>
<li>Khi dự đoán, ta có thể dùng triệt phi cực đại để loại bỏ các khung
chứa dự đoán tương tự nhau, từ đó đơn giản hóa kết quả.</li>
</ul>
</div>
<div class="section" id="bai-tap">
<h2><span class="section-number">13.4.6. </span>Bài tập<a class="headerlink" href="#bai-tap" title="Permalink to this headline">¶</a></h2>
<!--
1. Change the `sizes` and `ratios` values in the `multibox_prior` function and observe the changes to the generated anchor boxes.
2. Construct two bounding boxes with an IoU of 0.5, and observe their coincidence.
3. Verify the output of offset `labels[0]` by marking the anchor box offsets as defined in this section (the constant is the default value).
4. Modify the variable `anchors` in the "Labeling Training Set Anchor Boxes" and "Output Bounding Boxes for Prediction" sections. How do the results change?
--><ol class="arabic simple">
<li>Hãy thay đổi giá trị <code class="docutils literal notranslate"><span class="pre">size</span></code> và <code class="docutils literal notranslate"><span class="pre">ratios</span></code> trong hàm
<code class="docutils literal notranslate"><span class="pre">multibox_prior</span></code> và quan sát sự thay đổi của các khung neo được
tạo.</li>
<li>Tạo hai khung chứa với giá trị IoU là 0.5 và quan sát sự chồng nhau
giữa chúng.</li>
<li>Xác thực kết quả độ dời <code class="docutils literal notranslate"><span class="pre">labels[0]</span></code> bằng cách đánh dấu các độ dời
của khung neo như định nghĩa trong phần này (hằng số là một giá trị
mặc định).</li>
<li>Thay đổi biến <code class="docutils literal notranslate"><span class="pre">anchors</span></code> trong phần “Gán nhãn Khung neo ở tập Huấn
luyện” và “Khung chứa khi Dự đoán”. Kết quả thay đổi như thế nào?</li>
</ol>
</div>
<div class="section" id="thao-luan">
<h2><span class="section-number">13.4.7. </span>Thảo luận<a class="headerlink" href="#thao-luan" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://discuss.d2l.ai/t/370">Tiếng Anh - MXNet</a></li>
<li><a class="reference external" href="https://forum.machinelearningcoban.com/c/d2l">Tiếng Việt</a></li>
</ul>
</div>
<div class="section" id="nhung-nguoi-thuc-hien">
<h2><span class="section-number">13.4.8. </span>Những người thực hiện<a class="headerlink" href="#nhung-nguoi-thuc-hien" title="Permalink to this headline">¶</a></h2>
<p>Bản dịch trong trang này được thực hiện bởi:</p>
<ul class="simple">
<li>Đoàn Võ Duy Thanh</li>
<li>Nguyễn Mai Hoàng Long</li>
<li>Phạm Minh Đức</li>
<li>Phạm Đăng Khoa</li>
<li>Đỗ Trường Giang</li>
<li>Lê Khắc Hồng Phúc</li>
<li>Nguyễn Văn Cường</li>
</ul>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">13.4. Khung neo</a><ul>
<li><a class="reference internal" href="#sinh-nhieu-khung-neo">13.4.1. Sinh nhiều Khung neo</a></li>
<li><a class="reference internal" href="#giao-tren-hop">13.4.2. Giao trên Hợp</a></li>
<li><a class="reference internal" href="#gan-nhan-khung-neo-trong-tap-huan-luyen">13.4.3. Gán nhãn Khung neo trong tập Huấn luyện</a></li>
<li><a class="reference internal" href="#khung-chua-khi-du-doan">13.4.4. Khung chứa khi Dự đoán</a></li>
<li><a class="reference internal" href="#tom-tat">13.4.5. Tóm tắt</a></li>
<li><a class="reference internal" href="#bai-tap">13.4.6. Bài tập</a></li>
<li><a class="reference internal" href="#thao-luan">13.4.7. Thảo luận</a></li>
<li><a class="reference internal" href="#nhung-nguoi-thuc-hien">13.4.8. Những người thực hiện</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="bounding-box_vn.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L fas fa-arrow-left fa-lg"></i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>13.3. Phát hiện Vật thể và Khoanh vùng Đối tượng (Khung chứa)</div>
         </div>
     </a>
     <a id="button-next" href="multiscale-object-detection_vn.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
         <i class="pagenation-arrow-R fas fa-arrow-right fa-lg"></i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>13.5. Phát hiện Vật thể Đa tỷ lệ</div>
        </div>
     </a>
  </div>
        
        </main>
    </div>
  </body>
</html>